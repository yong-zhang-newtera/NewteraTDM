/*
* @(#)ParseTreeTransformer.cs
*
* Copyright (c) 2005 Newtera, Inc. All rights reserved.
*
*/
namespace Newtera.ParserGen.ParseTree
{
	using System;
	using System.Collections;

	using antlr;
	
	/// <summary>
	/// Transform a antlr parse tree into a parse tree of IParseTreeNode type
	/// in order to isolate the antlr parse tree from the rest of code.
	/// </summary>
	/// <version>  1.0.1 28 Nov 2005</version>
	/// <author>  Yong Zhang</author>
	public class ParseTreeTransformer
	{
		static internal Hashtable _tokenTable;

		/// <summary>
		/// Infer the node type from a IParseTreeNode item
		/// </summary>
		/// <param name="root">The root of parse tree generated by antlr.</param>
		/// <returns>The root of transformed parse tree with IParseTreeNode as node type.</returns>
		public static IParseTreeNode Transform(antlr.ParseTree root)
		{
			// initialize a hashtable for predefined tokens for performance purpose
			_tokenTable = new Hashtable();
			for (int i = 0; i < PredefinedTokens.PREDEFINED_TOKENS.Length; i++)
			{
				_tokenTable.Add(PredefinedTokens.PREDEFINED_TOKENS[i], "1");
			}

			IParseTreeNode parent = CreateParseTreeNode(root);

			if (parent != null)
			{
				CreateChildrenNodes(parent, root);
			}

			return parent;
		}

		/// <summary>
		/// Create child tree nodes for an IParseTreeNode instance
		/// </summary>
		/// <param name="parentTreeNode">The parent tree node of IParseTreeNode.</param>
		/// <param name="parentNode">The parent antlr tree node</param>
		private static void CreateChildrenNodes(IParseTreeNode parentTreeNode, antlr.ParseTree parentNode)
		{
			IParseTreeNode childNode;
			antlr.ParseTree child = (antlr.ParseTree) parentNode.getFirstChild();

			while (child != null)
			{
				childNode = CreateParseTreeNode(child);

				parentTreeNode.Children.Add(childNode);

				childNode.Parent = parentTreeNode;

				// create the children of the child node recursively
				CreateChildrenNodes(childNode, child);

				// move the sibling
				child = (antlr.ParseTree) child.getNextSibling();
			}
		}

		/// <summary>
		/// Create a IParseTreeNode according to the type of an antlr parse tree node.
		/// </summary>
		/// <param name="node">antlr parse tree node</param>
		/// <returns>A IParseTreeNode instance.</returns>
		private static IParseTreeNode CreateParseTreeNode(antlr.ParseTree node)
		{
			IParseTreeNode treeNode = null;

			if (node is ParseTreeRule)
			{
				treeNode = new ParseTreeRuleNode();
				treeNode.Name = ((ParseTreeRule) node).getRuleName();
			}
			else if (node is ParseTreeToken)
			{
				ParseTreeToken token = ((ParseTreeToken) node);
				string tokenName = token.getTokenName();

				// literal doesn't have a token name value
				if (tokenName != null && tokenName.StartsWith("\"") &&
					tokenName.EndsWith("\""))
				{
					// get ride of the quotes around the token name
					tokenName = tokenName.Substring(1, tokenName.Length - 2);
					if (IsPredefined(tokenName))
					{
						// predefined token name
						treeNode = new ParseTreeTokenNode();
						treeNode.Name = tokenName;
					}
					else
					{
						treeNode = new ParseTreeLiteralNode();
						treeNode.Name = tokenName;
					}
				}
				else
				{
					treeNode = new ParseTreeLiteralNode();
					treeNode.Name = tokenName;
				}
				
				string tokenText = token.ToString();
				treeNode.Text = tokenText;
				int pos = ((ParseTreeToken) node).getTokenPosition();
				if (pos > 0)
				{
					treeNode.TextStart = token.getTokenPosition() - 1;
				}
				else
				{
					treeNode.TextStart = 0;
				}
				treeNode.TextLength = tokenText.Length;
			}

			return treeNode;
		}

		private static bool IsPredefined(string tokenName)
		{
			bool status = false;

			if (ParseTreeTransformer._tokenTable[tokenName] != null)
			{
				status = true;
			}

			return status;
		}
	}
}