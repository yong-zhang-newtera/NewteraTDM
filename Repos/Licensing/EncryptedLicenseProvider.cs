//
//      FILE:   EncryptedLicenseProvider.cs
//
//    AUTHOR:   Grant Frisken
//
// COPYRIGHT:   Copyright 2005 
//              Infralution
//              6 Bruce St 
//              Mitcham Australia
//
using System;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Security.Cryptography;
using System.Diagnostics;
using System.Text;
using System.IO;
using System.Xml;
using System.Globalization;
using System.Reflection;
namespace Infralution.Licensing
{
    /// <summary>
    /// Defines a .NET LicenseProvider that uses encrypted licenses generated by the 
    /// Infralution Licensing System.
    /// </summary>
    /// <remarks>
    /// <p>The Infralution Licensing System provides a secure way of licensing .NET controls,
    /// components and applications.   Licenses are protected using public key encryption to
    /// minimize possibility of cracking.</p>
    /// <p>Components or controls use the <see cref="LicenseProviderAttribute"/> to specify
    /// this class as the LicenseProvider </p>
    /// </remarks>
    /// <example>
    /// This example demonstrates the typical usage of the EncryptedLicenseProvider to license a component or
    /// control.  The component/control must first initialize the EncryptedLicenseProvider with the public 
    /// key encryption parameters required to validate the license using <see cref="SetParameters"/>.  
    /// It can then use the .NET license manager to obtain a license for the current context 
    /// (runtime or design).  If there is not a valid license the component designer can  
    /// choose the appropriate course of action based on the context.  In this case the code uses the generic
    /// Infralution.Licensing.LicenseInstallForm to prompt the user to install a license - but allows use of 
    /// the component without a license for evaluation purposes. Applications created using the unlicensed evaluation 
    /// component will display a nag MessageBox.
    /// <code lang="C#" escaped="true" >
    /// #using Infralution.Licensing;
    /// #using System.ComponentModel;
    /// [LicenseProvider(typeof(Infralution.Licensing.EncryptedLicenseProvider))]
    /// public class MyControl : Control
    /// {
    ///     const string _licenseParameters = 
    ///        @"<LicenseParameters>
    ///             <RSAKeyValue>
    ///                 <Modulus>z7ijwu7osE4HcGZH7+PhOYw3WuZp/+1szNEjrEo61WVO2sklsdVJpjShXPzUDjlDDvnIFZo4d0l8IFswCYleRS+5PVOkqH0OnAHOSIvoHMNxRyKi9klj7ZD55sKfDJu17MUsjLFLc741B8EvQ3dXPLQoTc+TF5mKOm6o8BnrSuU=</Modulus>
    ///                 <Exponent>AQAB</Exponent>
    ///             </RSAKeyValue>
    ///             <DesignSignature>NqPti5+oayvPPlaETb5gNi9u32sze0o9AhlVEtWm3rfo3gGV/jKXDqQBd9Icy9xgfrEOVKvCyrhnCUEowQDOBPaVMiDqdm9UBRM/KAQt4kUAb2bhl8W47R09bikvahfJWfP+zyic3oin61B1jvuI2CSYjiRi4a5Qz2hudDP5MxM=</DesignSignature>
    ///             <RuntimeSignature>lL2tfh7eUgkZS+I0/yoRowAP7p++zXma4JgO/Npf0QXnbBy3pKw+B5U9jtfwydKleM22Wgk/KBG5uyYXWaJeG/Pe6I29uLD1s5uo+Y9EzVaXDdi9HMQwIIvrv7dcgZlPPkzmkSm1X3uqfHl9R4+NfP9noDBKiQBVSWkem/iH87E=</RuntimeSignature>
    ///          </LicenseParameters>";
    ///
    ///     public MyControl()
    ///     {
    ///         InitializeComponent();
    ///         EncryptedLicenseProvider.SetParameters(_licenseParameters);
    ///         License license;
    ///         if (!LicenseManager.IsValid(typeof(MyControl), this, out license))
    ///         {
    ///             if (LicenseManager.CurrentContext.UsageMode == LicenseUsageMode.Runtime)
    ///             {
    ///                 MessageBox.Show("This application was created using an unlicensed version of MyControl", 
    ///                                 "Unlicensed Application");
    ///             }
    ///             else
    ///             {
    ///                 LicenseInstallForm form = new LicenseInstallForm();
    ///                 form.ShowDialog("MyControl", "www.mycompany.com", typeof(MyControl)); 
    ///             }
    ///         }
    ///     }
    /// } 
    /// </code>
    /// <code lang ="Visual Basic">
    /// Imports System.ComponentModel
    /// Imports Infralution.Licensing
    /// &lt;LicenseProvider(GetType(Infralution.Licensing.EncryptedLicenseProvider))&gt; _
    /// Public Class MyControl
    ///    Inherits System.Windows.Forms.UserControl
    ///
    ///    Const _licenseParameters As String = _
    ///         "&lt;LicenseParameters&gt;" &amp; _
    ///         "       &lt;RSAKeyValue&gt;" &amp; _
    ///         "       &lt;Modulus&gt;2/dDoUDRnh2gT//5UhGkQRnviVmbrqZj6JdMHhMfZsXslK3x4Yz2QFjpjWtKI2REj8Z3rLd0iOHlOgEaRCM82qGaSMyaoYBYovOtIqU20hpYS6VBtNzwQCJ58d27cnQnMiAmpAjfnKc+gSD/ZIJeO6FdTjfx86+aWrsMOiSpjFk=&lt;/Modulus&gt;" &amp; _
    ///         "       &lt;Exponent&gt;AQAB&lt;/Exponent&gt;" &amp; _
    ///         "       &lt;/RSAKeyValue&gt;" &amp; _
    ///         "       &lt;DesignSignature&gt;IGODC7CpxUR/sFHG38Z09/tpCK115hGWHNm7HvziN/RAw2H7i5o4F6vwgSF7+Uw0ZBKALNqGXWZQg+vaskbf4cotbN1SAhSi3/qYYeH7s5tAiS4ZJfN4DVDaB/IZOfL+3X+hehuO+Ot+X/u8cDqZKCA+1kxeSX4aqwJ+iFwWaAM=&lt;/DesignSignature&gt;" &amp; _
    ///         "       &lt;RuntimeSignature&gt;xaala0UVs/pvODuBtGxJ/V8R633EWmprSYZga0rVA5C3+TdSl5ywHPc2OXVLvm4MyqtK7VX0bsnCZXMKkcek0BkV7TWOIt0xb5ORu1L5iKpOqqXuNhdrTDF9M+FXwQAFPLmts/HObZ4Ul89PmSbTG3pjhQVVUA20ioj7AlEcLQo=&lt;/RuntimeSignature&gt;" &amp; _
    ///         "&lt;/LicenseParameters&gt;"
    ///
    ///    Public Sub New()
    ///         MyBase.New()
    ///         InitializeComponent()
    ///         EncryptedLicenseProvider.SetParameters(_licenseParameters)
    ///         Dim slicense as License
    ///         If Not LicenseManager.IsValid(GetType(MyControl), Me, slicense) Then
    ///             If LicenseManager.CurrentContext.UsageMode = LicenseUsageMode.Runtime Then
    ///                 MessageBox.Show("This application was created using an unlicensed version of MyControl", "Unlicensed Application")
    ///             Else
    ///                 Dim myForm As New LicenseInstallForm
    ///                 myForm.ShowDialog("MyControl", "www.mycompany.com", GetType(MyControl))
    ///             End If
    ///         End If
    ///    End Sub
    /// End Class   
    /// </code>
    /// </example>
    /// <seealso cref="EncryptedLicense"/>
    public class EncryptedLicenseProvider : LicenseProvider
	{

        #region Member Variables

        private static string _rsaParameters;
        private static byte[] _designSignature;
        private static byte[] _runtimeSignature;

        private static byte[] _desKey = new byte []  { 0x92, 0x15, 0x38, 0xA1, 0x12, 0xED, 0xB3, 0xC2 };
        private static byte[] _desIV = new byte []  { 0xAD, 0x3F, 0xC6, 0x11, 0x47, 0x90, 0xDD, 0xA1 };
       
        private const int keyLength = 7;

        // the license parameters for the Licensing System itself
        //
        private const string _systemParameters = @"<LicenseParameters><RSAKeyValue><Modulus>u0Uz9OHGLVyLPZul6xeJDmFonpRo7dxI+26vxpm5vU0XHYp/7TQzqOcJVnSW1U6fIDHYynKIwfV/AzwVRV6K1dJB+Ag+bfDExQgJSniEVJq88wXz0iyyhklOx69F37Fglvz4m5p8xvG95KPrKkNHju3dp7gKr/XdfHeqO5MipEE=</Modulus><Exponent>AQAB</Exponent></RSAKeyValue><DesignSignature>Rafnrs1FVMy497Y2Bq38LFw3t2vvR2g6qWhC8BCD5FH1Rs7ArcnuQ093AalWqdhZPPvVvEbVltiFOKM0Ycr58J1uXxAUOXtd54wKE2IdfsfsbLiCXarUteFsKdmRO5dylEupq/oyGKaDHKm6PpDKKMgkofQ4Z1M7kq7pVa0gZUk=</DesignSignature><RuntimeSignature>pn47clfpjjV4wUG5YGHPZHyZFaJwEdHVGX8vh4ifSeHtMFxtLDdZg/YFgNKqRAr337bdFgz6YgWjfpBmP6lGB1ydKcT24aF/6DplaPoJiuovJrkE38iOeVLiP4vBd/7tuYc7KObCdenro/02Ur/4j6UL4UxBQsbjVUjuJM3jd80=</RuntimeSignature></LicenseParameters>";

        // the license for the Licensing System
        //
        private static System.ComponentModel.License _systemLicense;

        #endregion

        #region Public Interface

        /// <summary>
        /// Set the parameters used to validate licenses created by this provider.
        /// </summary>
        /// <remarks>
        /// This must be called by the client software prior to obtaining licenses using the EncryptedLicenseProvider.
        /// The parameters are generated using the Infralution License Key Generator and pasted into the calling client code.
        /// </remarks>
        /// <param name="licenseParameters">An XML string containing parameters used to validate licenses</param>
        public static void SetParameters(string licenseParameters)
        {
            // parse the validation parameters
            // 
            XmlReader reader = new XmlTextReader(licenseParameters, XmlNodeType.Element, null);
            while (reader.Read())
            {
                if (reader.IsStartElement())
                {
                    if (reader.LocalName == "RSAKeyValue")
                    {
                        _rsaParameters = reader.ReadOuterXml();
                    }
                    if (reader.LocalName == "DesignSignature")
                    {
                        string key = reader.ReadElementString();
                        _designSignature = Convert.FromBase64String(key);
                    }
                    if (reader.LocalName == "RuntimeSignature")
                    {
                        string key = reader.ReadElementString();
                        _runtimeSignature = Convert.FromBase64String(key);
                    }
                }
            }
            reader.Close();
        }

        /// <summary>
        /// Generate the XML license parameter string that is used to validate licenses generated using the 
        /// given password
        /// </summary>
        /// <param name="password">The password used to encrypted the license data</param>
        /// <returns>An XML string which is used to initialise the EncryptedLicenseProvider</returns>
        public string GenerateLicenseParameters(string password)
        {
            RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(1024);        
            string rsaParam = rsa.ToXmlString(false);

            byte[] designKey = GetEncryptionKey(password); 
            byte[] designSignature = rsa.SignData(designKey, new SHA1CryptoServiceProvider());

            // encrypt the design key to produce the runtime key
            //
            DESCryptoServiceProvider des = new DESCryptoServiceProvider();
            des.Key = _desKey; 
            des.IV = designKey;
            byte[] encKey = des.CreateEncryptor().TransformFinalBlock(designKey, 0, designKey.Length);
            byte[] runtimeKey = new byte[ArraySize(8)];
            Array.Copy(encKey, 0, runtimeKey, 0, keyLength);

            // sign the runtime key
            //
            byte[] runtimeSignature = rsa.SignData(runtimeKey, new SHA1CryptoServiceProvider());

            // write the license parameters out to an XML string
            //
            MemoryStream stream = new MemoryStream();
            XmlTextWriter writer = new XmlTextWriter(stream, Encoding.ASCII);
            writer.WriteStartElement("LicenseParameters");  
            writer.WriteRaw(rsaParam);
            writer.WriteElementString("DesignSignature", Convert.ToBase64String(designSignature));
            writer.WriteElementString("RuntimeSignature", Convert.ToBase64String(runtimeSignature));
            writer.WriteEndElement();
            writer.Close();
            string xml = ASCIIEncoding.ASCII.GetString(stream.ToArray());
            stream.Close();
            return xml;
        }

        /// <summary>
        /// Generate a new encrypted license using the given password
        /// </summary>
        /// <param name="password">The password used to encrypted the license data</param>
        /// <param name="productInfo">User defined data about the product being licensed</param>
        /// <param name="serialNo">The unique license serial number</param>
        /// <returns>A hex encoded ecnrypted license key</returns>
        /// <remarks>
        /// If there is no installed license for the Infralution Licensing System then the only 
        /// allowed password is "TEST" and the only allowed serial numbers are 1 or 0.  To use the
        /// licensed version of this method ensure that the file Infralution.Licensing.EncryptedLicenseProvider.lic
        /// exists in the same directory as the Infralution.Licensing.dll and contains a valid
        /// license key for the Licensing System.
        /// </remarks>
        public virtual string GenerateKey(string password, string productInfo, UInt16 serialNo)
        {
            // Public Key token for the Infralution signed assemblies
            //            
            byte[] requiredToken = { 0x3E, 0x7E, 0x8E, 0x37, 0x44, 0xA5, 0xC1, 0x3F };
            byte[] designKey = GetEncryptionKey(password); 
            byte[] productData = ASCIIEncoding.UTF8.GetBytes(productInfo);
            byte[] clientData = BitConverter.GetBytes(serialNo);
            byte[] payload = new byte[ArraySize(productData.Length + clientData.Length)];
            byte[] publicKeyToken = Assembly.GetExecutingAssembly().GetName().GetPublicKeyToken();
            byte[] testKey = { 0x3E, 0x7E, 0x8E, 0x37, 0x44, 0xA5, 0xC1, 0x3F };
            
            clientData.CopyTo(payload, 0);
            productData.CopyTo(payload, 2);
 
#if CHECK_PUBLIC_KEY

            const string passwordErrorMsg = "The only allowable password in evaluation mode is 'TEST'";
            const string serialNoErrorMsg = "The only allowable serial numbers in evaluation mode are '0' or '1'";

            // if the Licensing System is not licensed then we need to check the password and client ID
            //
            if (SystemLicense == null)
            {
                if (password != "TEST")
                    throw new LicenseException(typeof(EncryptedLicenseProvider), this, passwordErrorMsg);
                if (serialNo < 0 || serialNo > 1)
                    throw new LicenseException(typeof(EncryptedLicenseProvider), this, serialNoErrorMsg);
            }

            // Validate this assembly - if it isn't signed with the correct public key
            // then copy rubbish into the key.  This is to make it just a little more
            // difficult for the casual hacker.
            //
            if (!ArrayEqual(publicKeyToken, requiredToken))
            {
                _desKey.CopyTo(requiredToken, 0);
            }
#endif
        
            // encrypt the payload using the design key
            //
            DESCryptoServiceProvider des = new DESCryptoServiceProvider();
            des.Key = _desKey; 
            des.IV = designKey;
            byte[] encPayload = des.CreateEncryptor().TransformFinalBlock(payload, 0, payload.Length);

            // Combine the design key and encrypted payload 
            // Note that only the first 7 bytes of the key contain information so we
            // only pack this much information - this enables us to reduce the size of
            // the final key by 8 bytes.
            //
            byte[] data = new byte[ArraySize(keyLength + encPayload.Length)];
            designKey.CopyTo(data, 0);
            encPayload.CopyTo(data, keyLength);

            // encrypt again to obscure the design key - this time using preset encryption key
            //
            des.IV = _desIV;
            byte[] encData = des.CreateEncryptor().TransformFinalBlock(data, 0, data.Length);
           
            return ToHex(encData);
        }

        /// <summary>
        /// Install a license for the given type.
        /// </summary>
        /// <remarks>
        /// This method is used by client applications to allow customers to register license for components.  The 
        /// generic Infralution.Licensing.LicenseInstallForm uses this method to install licenses.  Client
        /// components may implement their own registration forms that call this method.
        /// You must call <see cref="SetParameters"/> before using this method.
        /// </remarks>
        /// <param name="type">The type to install the license for</param>
        /// <param name="licenseKey">The license key to install</param>
        /// <returns>A license if succesful or null/nothing if not</returns>
        public virtual EncryptedLicense InstallLicense(Type type, string licenseKey)
        {
            // Create an instance of the provider to validate the license
            //
            EncryptedLicense license = LoadLicense(LicenseManager.CurrentContext, type, licenseKey);
            if (license != null)
            {
                string licenseFile = GetLicenseFilePath(LicenseManager.CurrentContext, type);             
                WriteKeyToFile(licenseFile, licenseKey);
            }
            return license;
        }

        /// <summary>
        /// Validate that the given license key is valid for the current licensing parameters
        /// </summary>
        /// <param name="licenseKey">The license key to validate</param>
        /// <returns>The encrypted license if the key is valid otherwise null</returns>
        /// <remarks>
        /// This method provides a mechanism to validate that a given license key is valid
        /// prior to attempting to install it.   This can be useful if you want to check
        /// the <see cref="EncryptedLicense.ProductInfo"/> before installing the license.
        /// You must call <see cref="SetParameters"/> before using this method.
        /// </remarks>
        public virtual EncryptedLicense ValidateLicenseKey(string licenseKey)
        {
            return LoadLicense(LicenseManager.CurrentContext, null, licenseKey);
        }

		/// <summary>
		/// Gets the product info embedded in the license key
		/// </summary>
		/// <param name="licenseKey">The license key</param>
		/// <returns>The string representing the product info</returns>
		public virtual string GetProductInfo(string licenseKey)
		{
			// check that validation parameters have been set by the client
			//
			if (_rsaParameters == null || _designSignature == null || _runtimeSignature == null) 
				throw new InvalidOperationException("EncryptedLicenseProvider.SetParameters must be called prior to using the EncryptedLicenseProvider");
			if (licenseKey == null) return null;

			try
			{
				byte[] encData = FromHex(licenseKey);

				DESCryptoServiceProvider des = new DESCryptoServiceProvider();
				des.Key = _desKey; 
				des.IV = _desIV;
            
				byte[] data = des.CreateDecryptor().TransformFinalBlock(encData, 0, encData.Length);
            
				// extract the encryption key and encrypted product data - note that the encryption
				// key has only 7 significant bytes 
				//
				byte[] encryptionKey = new byte[ArraySize(8)];
				byte[] encPayload = new byte[ArraySize(data.Length - keyLength)];

				Array.Copy(data, 0, encryptionKey, 0, keyLength);
				Array.Copy(data, keyLength, encPayload, 0, encPayload.Length);

				// validate that the password matches what the client is expecting
				//
				RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();
				rsa.FromXmlString(_rsaParameters);

				// decrypt the payload using the encryption key
				//
				des.IV = encryptionKey;
				byte[] payload = des.CreateDecryptor().TransformFinalBlock(encPayload, 0, encPayload.Length);
				byte[] productData = new byte[ArraySize(payload.Length - 2)];
				Array.Copy(payload, 2, productData, 0, productData.Length);
             
				UInt16 serialNo = BitConverter.ToUInt16(payload, 0);
				string product = System.Text.ASCIIEncoding.UTF8.GetString(productData); 

				return product;
			}
			catch
			{
				return null;
			}
		}

        /// <summary>
        /// Get a license (if installed) for the given context, type and instance
        /// </summary>
        /// <param name="context">The context (design or runtime)</param>
        /// <param name="type">The type to get the license for</param>
        /// <param name="instance"></param>
        /// <param name="allowExceptions">If true LicenseException is thrown if a valid license cannot be loaded</param>
        /// <returns>An encrypted license</returns>
        /// <remarks>
        /// You must call <see cref="SetParameters"/> before calling this method either directly or
        /// indirectly by via a call to <see cref="LicenseManager.IsValid"/>
        /// </remarks>
        public override License GetLicense(LicenseContext context, Type type, object instance, bool allowExceptions)
        {
            string licenseKey = GetLicenseKey(context, type);
            License license = LoadLicense(context, type, licenseKey);
            if (license == null && allowExceptions)
            {
                if (instance == null)
                    throw new LicenseException(type);
                else
                    throw new LicenseException(type, instance);
            }
            return license;
        }

        #endregion

        #region Internal Methods

        /// <summary>
        /// Return the license for the Infralution Licensing System
        /// </summary>
        /// <returns>The license data if successful or null if not</returns>
        internal static License SystemLicense
        {
            get
            {
                if (_systemLicense == null)
                {
                    SetParameters(_systemParameters);
                    EncryptedLicenseProvider provider = new EncryptedLicenseProvider();
                    _systemLicense = provider.GetLicense(System.ComponentModel.LicenseManager.CurrentContext, typeof(EncryptedLicenseProvider), null, false);
                }
                return _systemLicense;
            }
        }

        /// <summary>
        /// Return the license information from the given license key
        /// </summary>
        /// <param name="licenseKey">The license key to extract the license information from</param>
        /// <param name="password">The password - required to open the license key</param>
        /// <returns>The license data if successful or null if not</returns>
        internal EncryptedLicense GetLicense(string licenseKey, string password)
        {
            try
            {
                byte[] encData = FromHex(licenseKey);
                byte[] requiredToken = { 0x3E, 0x7E, 0x8E, 0x37, 0x44, 0xA5, 0xC1, 0x3F };
                byte[] publicKeyToken = Assembly.GetExecutingAssembly().GetName().GetPublicKeyToken();

                // Validate this assembly - if it isn't signed with the correct public key
                // then copy rubbish into the key.  This is to make it just a little more
                // difficult for the casual hacker.
                //
#if CHECK_PUBLIC_KEY

                if (!ArrayEqual(publicKeyToken, requiredToken))
                {
                    _desKey.CopyTo(requiredToken, 0);
                }
#endif

                DESCryptoServiceProvider des = new DESCryptoServiceProvider();
                des.Key = _desKey; 
                des.IV = _desIV;
            
                byte[] data = des.CreateDecryptor().TransformFinalBlock(encData, 0, encData.Length);
            
                // extract the encryption key and encrypted product data - note that the encryption
                // key has only 7 significant bytes 
                //
                byte[] encryptionKey = new byte[ArraySize(8)];
                byte[] encPayload = new byte[ArraySize(data.Length - keyLength)];

                Array.Copy(data, 0, encryptionKey, 0, keyLength);
                Array.Copy(data, keyLength, encPayload, 0, encPayload.Length);

                // validate that the password matches that passed in
                //
                byte[] requiredEncryptionKey = GetEncryptionKey(password);
                if (!ArrayEqual(encryptionKey, requiredEncryptionKey))
                {
                    return null;
                }

                // decrypt the payload using the encryption key
                //
                des.IV = encryptionKey;
                byte[] payload = des.CreateDecryptor().TransformFinalBlock(encPayload, 0, encPayload.Length);
                byte[] productData = new byte[ArraySize(payload.Length - 2)];
                Array.Copy(payload, 2, productData, 0, productData.Length);
             
                UInt16 serialNo = BitConverter.ToUInt16(payload, 0);
                string productInfo = System.Text.ASCIIEncoding.UTF8.GetString(productData); 

                return new EncryptedLicense(licenseKey, serialNo, productInfo);
            }
            catch
            {
                return null;
            }
        }

        #endregion

        #region Local Methods

        /// <summary>
        /// Return the array size to use when declaring an array of the given length.
        /// </summary>
        /// <param name="length">The length of the array you are declaring</param>
        /// <returns>The size to declare the array</returns>
        /// <remarks>
        /// This is used to account for the difference between declaring VB and C# arrays and
        /// permit automatic conversion of the code to VB
        /// </remarks>
        private static int ArraySize(int length)
        {
            return length;
        }

        /// <summary>
        /// Return the given input string stripped of the given characters
        /// </summary>
        /// <param name="value">The string to strip</param>
        /// <param name="characters">The characters to strip from the string</param>
        /// <returns>The input string with the given characters removed</returns>
        private static string Strip(string value, string characters)
        {
            if (value == null) return null;
            StringBuilder sb = new StringBuilder();
            foreach (char ch in value)
            {
                if (characters.IndexOf(ch, 0) < 0)
                {
                    sb.Append(ch);
                }
            }
            return sb.ToString();       
        }

        /// <summary>
        /// Converts a byte array into a hexadecimal representation.
        /// </summary>
        /// <param name="data">The byte data to convert</param>
        /// <returns>Hexadecimal representation of the data</returns>
        private static string ToHex(byte[] data)
        {
            StringBuilder sb = new StringBuilder();
            for (int i=0; i < data.Length; i++)
            {
                if (i > 0 && i % 2 == 0)
                {
                    sb.Append("-");
                }
                sb.Append(data[i].ToString("X2"));
            }
            return sb.ToString();
        }

        /// <summary>
        /// Converts a hexadecimal string into a byte array.
        /// </summary>
        /// <param name="hex">Te hexadecimal string to convert</param>
        /// <returns>The converted byte data</returns>
        private static byte[] FromHex(string hex)
        {
            string strippedHex = Strip(hex, "\t\r\n -");
            if (strippedHex == null || strippedHex.Length % 2 != 0) 
                throw new FormatException("Invalid hexadecimal string");
            byte[] result = new byte[ArraySize(strippedHex.Length / 2)];
            for (int i=0, j = 0; i < strippedHex.Length; i += 2, j++)
            {
                string s = strippedHex.Substring(i, 2);
                result[j] = byte.Parse(s, NumberStyles.HexNumber);                 
            }
            return result;
        }

        /// <summary>
        /// Are the contents of the two byte arrays equal
        /// </summary>
        /// <param name="a1">The first array</param>
        /// <param name="a2">The second array </param>
        /// <returns>True if the contents of the arrays is equal</returns>
        private static bool ArrayEqual(byte[] a1, byte[] a2)
        {
            if (a1 == a2) return true;
            if ((a1 == null) || (a2 == null)) return false;
            if (a1.Length != a2.Length) return false;
            for (int i=0; i < a1.Length; i++)
            {
                if (a1[i] != a2[i]) return false;
            }
            return true;
        }

        /// <summary>
        /// Generate an 8 byte DES encryption key using the given password
        /// </summary>
        /// <remarks>
        /// Only the first 7 bytes of the key returned are used.  This enables us
        /// to reduce the size of the final license keys by 8 bytes.
        /// </remarks>
        /// <param name="password">The password used to generate the key</param>
        /// <returns>An 8 byte key</returns> 
        private static byte[] GetEncryptionKey(string password)
        {
            byte[] key = new byte []  { 0xF2, 0xA1, 0x03, 0x9D, 0x63, 0x87, 0x35, 0x5E };
            byte[] iv = new byte []  { 0xAB, 0xB8, 0x94, 0x7E, 0x1D, 0xE5, 0xD1, 0x33 };

            DESCryptoServiceProvider des = new DESCryptoServiceProvider();
            des.Key = key;
            des.IV = iv;

            if (password.Length < 8) 
                password = password.PadRight(8, '*');
            byte[] data = ASCIIEncoding.ASCII.GetBytes(password);
            byte[] encData = des.CreateEncryptor().TransformFinalBlock(data, 0, data.Length);
            byte[] result = new byte[ArraySize(8)];
            Array.Copy(encData, 0, result, 0, keyLength);
            return result;
        }

        /// <summary>
        /// Extract the license for the given type from the given licenseKey
        /// </summary>
        /// <param name="context">The current licensing context</param>
        /// <param name="type">The type to be licensed</param>
        /// <param name="licenseKey">The encrypted hexadecimal license key</param>
        /// <returns>A license for the given type or NULL if the licenseKey was invalid</returns>
        private EncryptedLicense LoadLicense(LicenseContext context, Type type, string licenseKey)
        {
            // check that validation parameters have been set by the client
            //
            if (_rsaParameters == null || _designSignature == null || _runtimeSignature == null) 
                throw new InvalidOperationException("EncryptedLicenseProvider.SetParameters must be called prior to using the EncryptedLicenseProvider");
            if (licenseKey == null) return null;

            try
            {
                byte[] encData = FromHex(licenseKey);

                DESCryptoServiceProvider des = new DESCryptoServiceProvider();
                des.Key = _desKey; 
                des.IV = _desIV;
            
                byte[] data = des.CreateDecryptor().TransformFinalBlock(encData, 0, encData.Length);
            
                // extract the encryption key and encrypted product data - note that the encryption
                // key has only 7 significant bytes 
                //
                byte[] encryptionKey = new byte[ArraySize(8)];
                byte[] encPayload = new byte[ArraySize(data.Length - keyLength)];

                Array.Copy(data, 0, encryptionKey, 0, keyLength);
                Array.Copy(data, keyLength, encPayload, 0, encPayload.Length);

                // validate that the password matches what the client is expecting
                //
                RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();
                rsa.FromXmlString(_rsaParameters);

                if (context.UsageMode == LicenseUsageMode.Designtime)
                {
                    // if design time license requested then the license MUST be a design license
                    //
                    if (!rsa.VerifyData(encryptionKey, new SHA1CryptoServiceProvider(), _designSignature)) return null;
                }
                else
                {
                    // if runtime license requested then first check if the license is a runtime license
                    // also allow design licenses to work at runtime
                    //
                    if (!rsa.VerifyData(encryptionKey, new SHA1CryptoServiceProvider(), _runtimeSignature))
                    {
                        if (!rsa.VerifyData(encryptionKey, new SHA1CryptoServiceProvider(), _designSignature)) return null;
                    }
                }

                // decrypt the payload using the encryption key
                //
                des.IV = encryptionKey;
                byte[] payload = des.CreateDecryptor().TransformFinalBlock(encPayload, 0, encPayload.Length);
                byte[] productData = new byte[ArraySize(payload.Length - 2)];
                Array.Copy(payload, 2, productData, 0, productData.Length);
             
                UInt16 serialNo = BitConverter.ToUInt16(payload, 0);
                string product = System.Text.ASCIIEncoding.UTF8.GetString(productData); 

                // if in design time then create a runtime license and save it
                //
                if (context.UsageMode == LicenseUsageMode.Designtime && type != null)
                {
                    // create the runtime password by encrypting the design time license
                    //
                    byte[] encKey = des.CreateEncryptor().TransformFinalBlock(encryptionKey, 0, encryptionKey.Length);
                    byte[] runtimeKey = new byte[ArraySize(8)];
                    Array.Copy(encKey, 0, runtimeKey, 0, keyLength);

                    // encrypt the payload using the runtime key
                    //
                    des.IV = runtimeKey;
                    encPayload = des.CreateEncryptor().TransformFinalBlock(payload, 0, payload.Length);
      
                    // Combine the runtime key and encrypted payload 
                    // Note that only the first 7 bytes of the key contain information so we
                    // only pack this much information - this enables us to reduce the size of
                    // the final key by 8 bytes.
                    //
                    data = new byte[ArraySize(keyLength + encPayload.Length)];
                    runtimeKey.CopyTo(data, 0);
                    encPayload.CopyTo(data, keyLength);

                    // encrypt again to obscure the password - this time using preset encryption key
                    //
                    des.IV = _desIV;
                    encData = des.CreateEncryptor().TransformFinalBlock(data, 0, data.Length);
              
                    string runtimeLicenseKey = ToHex(encData);

                    // save the runtime key into the context
                    //
                    context.SetSavedLicenseKey(type, runtimeLicenseKey);            
                }
                return new EncryptedLicense(licenseKey, serialNo, product);
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// Read a license key from the given file
        /// </summary>
        /// <param name="licenseFile">The path to the license file to read the key from</param>
        /// <returns>The license key if any</returns>
        protected virtual string ReadKeyFromFile(string licenseFile)
        {
            string key = null;
            if (File.Exists(licenseFile)) 
            {
                Stream stream = new FileStream(licenseFile, FileMode.Open, FileAccess.Read, FileShare.Read);
                StreamReader reader = new StreamReader(stream);
                key = reader.ReadLine();
                reader.Close();
            }
            return key;
        }

        /// <summary>
        /// Write a license key to the given file
        /// </summary>
        /// <param name="licenseFile">The path to the license file to write the key to</param>
        /// <param name="licenseKey">The license key to write</param>
        protected virtual void WriteKeyToFile(string licenseFile, string licenseKey)
        {
            Stream stream = new FileStream(licenseFile, FileMode.Create, FileAccess.Write, FileShare.None);
            StreamWriter writer = new StreamWriter(stream);
            writer.WriteLine(licenseKey);
            writer.Close();
        }

        /// <summary>
        /// Return the license key for the given context and type
        /// </summary>
        /// <remarks>
        /// This can be overridden to change where the license key is stored by the provider.   For
        /// instance a derived class could override this method to store the key in the Registry.
        /// </remarks>
        /// <param name="context">The license context</param>
        /// <param name="type">The type to get the key for</param>
        /// <returns>The license key</returns>
        protected virtual string GetLicenseKey(LicenseContext context, Type type)
        {
            string key = null;
            if (context.UsageMode == LicenseUsageMode.Runtime) 
            {
                key = context.GetSavedLicenseKey(type, null);
            }

            // if we're in design mode or a suitable license key wasn't found in 
            // the runtime context look for a .LIC file
            //
            if (key == null) 
            {       				
                key = ReadKeyFromFile(GetLicenseFilePath(context, type));
            }
            return key;
        }

        /// <summary>
        /// Return the directory used to store license files
        /// </summary>
        /// <param name="context">The licence context</param>
        /// <param name="type">The type being licensed</param>
        /// <returns>The directory to look for license files</returns>
        protected virtual string GetLicenseDirectory(LicenseContext context, Type type)
        {
            string result = null;

            // try to use the type resolver service if available
            //
            if (context != null) 
            {
                ITypeResolutionService resolver = (ITypeResolutionService)context.GetService(typeof(ITypeResolutionService));
                if (resolver != null)
                    result = resolver.GetPathOfAssembly(type.Assembly.GetName());
            }
        
            if (result == null)
            {
                // use the code base if possible - because this works properly under ASP.NET
                // where as the Module.FullyQualifiedName points to a temporary file
                //
                result = type.Assembly.CodeBase;
                if (result.StartsWith(@"file:///"))
                {
                    result = result.Replace(@"file:///", "");
                }
                else
                {
                    result = type.Module.FullyQualifiedName;
                }
            }
            return Path.GetDirectoryName(result);
        }

        /// <summary>
        /// Called by GetLicenseKey to get the file path to obtain the license from (if there is no runtime license saved in the context)
        /// </summary>
        /// <remarks>
        /// This can be overridden to change the file used to store the design time license for the provider.   By default the
        /// the license file is stored in the same directory as the component executable with the name based on the fully
        /// qualified type name eg MyNamespace.MyControl.lic
        /// </remarks>
        /// <seealso cref="GetLicenseKey"/>
        /// <param name="context">The licence context</param>
        /// <param name="type">The type to get the license for</param>
        /// <returns>The path of the license file</returns>
        protected virtual string GetLicenseFilePath(LicenseContext context, Type type)
        {
            string dir = GetLicenseDirectory(context, type);
            return String.Format(@"{0}\{1}.lic", dir, type.FullName);
        }

 
        #endregion
	}

}
