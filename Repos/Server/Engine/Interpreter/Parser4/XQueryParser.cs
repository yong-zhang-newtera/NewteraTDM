//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.5.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from XQuery.g4 by ANTLR 4.5.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591


   // global code stuff that will be included in the source file just before the 'XQueryParser' class below
	using System.Collections;
	using Newtera.Server.Engine.Interpreter;
	using Newtera.Server.Engine.Vdom;

using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.5.1")]
[System.CLSCompliant(false)]
public partial class XQueryParser : Parser {
	public const int
		T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, T__7=8, T__8=9, 
		T__9=10, T__10=11, T__11=12, T__12=13, T__13=14, T__14=15, T__15=16, T__16=17, 
		T__17=18, T__18=19, T__19=20, STRING_LITERAL=21, STRING_QUOTE=22, NUMERIC_LITERAL=23, 
		Name=24, INLINE=25, INLINE_LEFT_BRACKET=26, INLINE_RIGHT_BRACKET=27, PREDEFINED_ENTITY_REF=28, 
		WS=29, SEMICOLON=30, EQUALS=31, L_PAREN=32, R_PAREN=33, COMMA=34, L_BRACKET=35, 
		R_BRACKET=36, COLON=37, D_COLON=38, L_BRACE=39, R_BRACE=40, DEREFERENCE=41, 
		AT=42, SLASH_AT=43, STAR=44, SLASH=45, SLASH_SLASH=46, MOD=47, STAR_COLON=48, 
		NOT_EQUALS=49, D_EQUALS=50, NOT_D_EQUALS=51, LESS_THAN=52, GREATER_THAN=53, 
		LESS_THAN_EQUALS=54, GREATER_THAN_EQUALS=55, PLUS=56, MINUS=57, BAR=58, 
		SET_EQUAL_TO=59, QUOTE=60, ESCAPED_QUOTE=61, S_QUOTE=62, SLASH_GREATER_THAN=63, 
		LESS_THAN_SLASH=64, DOLLAR=65;
	public const int
		RULE_start = 0, RULE_queryModule = 1, RULE_importAs = 2, RULE_exprSequence = 3, 
		RULE_expression = 4, RULE_pathExpression = 5, RULE_path = 6, RULE_xstep = 7, 
		RULE_basicExpression = 8, RULE_predicate = 9, RULE_variable = 10, RULE_flwrExpr = 11, 
		RULE_flClause = 12, RULE_forClause = 13, RULE_letClause = 14, RULE_whereClause = 15, 
		RULE_sortByClause = 16, RULE_sortSpecList = 17, RULE_sortSpec = 18, RULE_logicalOrExpression = 19, 
		RULE_logicalAndExpression = 20, RULE_rangeExpression = 21, RULE_equalityExpression = 22, 
		RULE_relationalExpression = 23, RULE_additiveExpression = 24, RULE_multiplicativeExpression = 25, 
		RULE_unaryExpression = 26, RULE_primitiveExpression = 27, RULE_functionCall = 28, 
		RULE_literal = 29, RULE_ifExpr = 30, RULE_elementConstructor = 31, RULE_elementContents = 32, 
		RULE_attribute = 33, RULE_enclosedExpr = 34;
	public static readonly string[] ruleNames = {
		"start", "queryModule", "importAs", "exprSequence", "expression", "pathExpression", 
		"path", "xstep", "basicExpression", "predicate", "variable", "flwrExpr", 
		"flClause", "forClause", "letClause", "whereClause", "sortByClause", "sortSpecList", 
		"sortSpec", "logicalOrExpression", "logicalAndExpression", "rangeExpression", 
		"equalityExpression", "relationalExpression", "additiveExpression", "multiplicativeExpression", 
		"unaryExpression", "primitiveExpression", "functionCall", "literal", "ifExpr", 
		"elementConstructor", "elementContents", "attribute", "enclosedExpr"
	};

	private static readonly string[] _LiteralNames = {
		null, "'import'", "'as'", "'return'", "'for'", "'in'", "'let'", "'where'", 
		"'sortby'", "'ascending'", "'descending'", "'or'", "'and'", "'to'", "'ni'", 
		"'like'", "'div'", "'null'", "'if'", "'then'", "'else'", null, null, null, 
		null, null, "'[['", "']]'", null, null, "';'", "'='", "'('", "')'", "','", 
		"'['", "']'", "':'", "'::'", "'{'", "'}'", "'=>'", "'@'", "'/@'", "'*'", 
		"'/'", "'//'", "'%'", "'*:'", "'!='", "'=='", "'!=='", "'<'", "'>'", "'<='", 
		"'>='", "'+'", "'-'", "'|'", "':='", null, "'\\\"'", "'''", "'/>'", "'</'", 
		"'$'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, "STRING_LITERAL", 
		"STRING_QUOTE", "NUMERIC_LITERAL", "Name", "INLINE", "INLINE_LEFT_BRACKET", 
		"INLINE_RIGHT_BRACKET", "PREDEFINED_ENTITY_REF", "WS", "SEMICOLON", "EQUALS", 
		"L_PAREN", "R_PAREN", "COMMA", "L_BRACKET", "R_BRACKET", "COLON", "D_COLON", 
		"L_BRACE", "R_BRACE", "DEREFERENCE", "AT", "SLASH_AT", "STAR", "SLASH", 
		"SLASH_SLASH", "MOD", "STAR_COLON", "NOT_EQUALS", "D_EQUALS", "NOT_D_EQUALS", 
		"LESS_THAN", "GREATER_THAN", "LESS_THAN_EQUALS", "GREATER_THAN_EQUALS", 
		"PLUS", "MINUS", "BAR", "SET_EQUAL_TO", "QUOTE", "ESCAPED_QUOTE", "S_QUOTE", 
		"SLASH_GREATER_THAN", "LESS_THAN_SLASH", "DOLLAR"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "XQuery.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }


	   // additional methods and members for the generated 'MyParser' class
		Interpreter _interpreter;
		Stack _stack;
		Stack _contextStack; // Soly used for providing context to the path embedded in a predicate
		
		public IExpr Parse()
		{
			return Parse(null);
		}
		
		public IExpr Parse(IExpr context)
		{
	        
			_stack = new Stack();
			_contextStack = new Stack();
			
			if (context != null)
			{
				_contextStack.Push(context);
			}
			
			start();
			
			if (_stack.Count != 1)
			{
				throw new Exception("Parser fatal error: Bad stack size: " + _stack.Count);
			}

			return  (IExpr) _stack.Pop();
		}	

	public XQueryParser(ITokenStream input)
		: base(input)
	{
		Interpreter = new ParserATNSimulator(this,_ATN);
	}
	public partial class StartContext : ParserRuleContext {
		public QueryModuleContext queryModule() {
			return GetRuleContext<QueryModuleContext>(0);
		}
		public StartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_start; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterStart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitStart(this);
		}
	}

	[RuleVersion(0)]
	public StartContext start() {
		StartContext _localctx = new StartContext(Context, State);
		EnterRule(_localctx, 0, RULE_start);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 70; queryModule();

					IExpr expr = (IExpr) _stack.Pop();
					_stack.Push(new QueryExpr(_interpreter, expr));
			    
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryModuleContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ImportAsContext[] importAs() {
			return GetRuleContexts<ImportAsContext>();
		}
		public ImportAsContext importAs(int i) {
			return GetRuleContext<ImportAsContext>(i);
		}
		public QueryModuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryModule; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterQueryModule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitQueryModule(this);
		}
	}

	[RuleVersion(0)]
	public QueryModuleContext queryModule() {
		QueryModuleContext _localctx = new QueryModuleContext(Context, State);
		EnterRule(_localctx, 2, RULE_queryModule);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 76;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==T__0) {
				{
				{
				State = 73; importAs();
				}
				}
				State = 78;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 79; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ImportAsContext : ParserRuleContext {
		public ITerminalNode[] Name() { return GetTokens(XQueryParser.Name); }
		public ITerminalNode Name(int i) {
			return GetToken(XQueryParser.Name, i);
		}
		public ImportAsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_importAs; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterImportAs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitImportAs(this);
		}
	}

	[RuleVersion(0)]
	public ImportAsContext importAs() {
		ImportAsContext _localctx = new ImportAsContext(Context, State);
		EnterRule(_localctx, 4, RULE_importAs);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 81; Match(T__0);
			State = 82; Match(Name);
			State = 83; Match(T__1);
			State = 84; Match(Name);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprSequenceContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(XQueryParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(XQueryParser.COMMA, i);
		}
		public ExprSequenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exprSequence; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterExprSequence(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitExprSequence(this);
		}
	}

	[RuleVersion(0)]
	public ExprSequenceContext exprSequence() {
		ExprSequenceContext _localctx = new ExprSequenceContext(Context, State);
		EnterRule(_localctx, 6, RULE_exprSequence);

			int depth = _stack.Count;
			
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 86; expression();
			State = 91;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 87; Match(COMMA);
				State = 88; expression();
				}
				}
				State = 93;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}

					IExpr expr = null;
					if (_stack.Count > depth)
					{
						ExprCollection exprs = new ExprCollection();
						while (_stack.Count > depth)
						{
							expr = (IExpr) _stack.Pop();
							exprs.Insert(0, expr);
						}
						_stack.Push(exprs);
					}
				
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public BasicExpressionContext basicExpression() {
			return GetRuleContext<BasicExpressionContext>(0);
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		ExpressionContext _localctx = new ExpressionContext(Context, State);
		EnterRule(_localctx, 8, RULE_expression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 96; basicExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PathExpressionContext : ParserRuleContext {
		public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		public PathContext path() {
			return GetRuleContext<PathContext>(0);
		}
		public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		public PathExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pathExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterPathExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitPathExpression(this);
		}
	}

	[RuleVersion(0)]
	public PathExpressionContext pathExpression() {
		PathExpressionContext _localctx = new PathExpressionContext(Context, State);
		EnterRule(_localctx, 10, RULE_pathExpression);

			bool hasSortBy = false;
			
		try {
			State = 109;
			switch ( Interpreter.AdaptivePredict(TokenStream,2,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 98; variable(false);
				State = 99; path();

							ExprCollection steps = (ExprCollection) _stack.Pop();
							IExpr context = (IExpr) _stack.Pop();
							_stack.Push(new Path(_interpreter, steps, context));
						
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 102; functionCall();
				State = 103; path();
				   
							ExprCollection steps = (ExprCollection) _stack.Pop();
							IExpr context = (IExpr) _stack.Pop();
							_stack.Push(new Path(_interpreter, steps, context));        
				        
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 106; path();

							ExprCollection steps = (ExprCollection) _stack.Pop();
							Path pathExpr = new Path(_interpreter, steps, null); 
							if (_contextStack.Count > 0)
							{
								IExpr context = (IExpr) _contextStack.Peek();
								pathExpr.Context = context;
							}
							_stack.Push(pathExpr); 			       
					    
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PathContext : ParserRuleContext {
		public XstepContext[] xstep() {
			return GetRuleContexts<XstepContext>();
		}
		public XstepContext xstep(int i) {
			return GetRuleContext<XstepContext>(i);
		}
		public PathContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_path; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterPath(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitPath(this);
		}
	}

	[RuleVersion(0)]
	public PathContext path() {
		PathContext _localctx = new PathContext(Context, State);
		EnterRule(_localctx, 12, RULE_path);

			int depth = _stack.Count;
			
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			do {
				{
				{
				State = 111; xstep();
				}
				}
				State = 114;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Name) | (1L << DEREFERENCE) | (1L << AT) | (1L << SLASH_AT) | (1L << SLASH) | (1L << SLASH_SLASH))) != 0) );

					IExpr step = null;
					if (_stack.Count > depth)
					{
						ExprCollection steps = new ExprCollection();
						while (_stack.Count > depth)
						{
							step = (IExpr) _stack.Pop();
							steps.Insert(0, step);
						}
						_stack.Push(steps);
					}
				
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class XstepContext : ParserRuleContext {
		public IToken p;
		public IToken t;
		public ITerminalNode[] Name() { return GetTokens(XQueryParser.Name); }
		public ITerminalNode Name(int i) {
			return GetToken(XQueryParser.Name, i);
		}
		public ITerminalNode SLASH() { return GetToken(XQueryParser.SLASH, 0); }
		public ITerminalNode SLASH_SLASH() { return GetToken(XQueryParser.SLASH_SLASH, 0); }
		public ITerminalNode SLASH_AT() { return GetToken(XQueryParser.SLASH_AT, 0); }
		public ITerminalNode DEREFERENCE() { return GetToken(XQueryParser.DEREFERENCE, 0); }
		public ITerminalNode AT() { return GetToken(XQueryParser.AT, 0); }
		public ITerminalNode COLON() { return GetToken(XQueryParser.COLON, 0); }
		public PredicateContext predicate() {
			return GetRuleContext<PredicateContext>(0);
		}
		public XstepContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xstep; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterXstep(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitXstep(this);
		}
	}

	[RuleVersion(0)]
	public XstepContext xstep() {
		XstepContext _localctx = new XstepContext(Context, State);
		EnterRule(_localctx, 14, RULE_xstep);

			int axisId = Axis.CHILD;
			string prefix = null;
			Step stepExpr = null;
			
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 128;
			switch (TokenStream.La(1)) {
			case SLASH:
				{
				State = 118; Match(SLASH);
				axisId = Axis.CHILD;
				}
				break;
			case SLASH_SLASH:
				{
				State = 120; Match(SLASH_SLASH);
				axisId = Axis.DESCENDANT;
				}
				break;
			case SLASH_AT:
				{
				State = 122; Match(SLASH_AT);
				axisId = Axis.ATTRIBUTE;
				}
				break;
			case DEREFERENCE:
				{
				State = 124; Match(DEREFERENCE);
				axisId = Axis.DEREFERENCE;
				}
				break;
			case AT:
				{
				State = 126; Match(AT);
				axisId = Axis.ATTRIBUTE;
				}
				break;
			case Name:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 133;
			switch ( Interpreter.AdaptivePredict(TokenStream,5,Context) ) {
			case 1:
				{
				State = 130; _localctx.p = Match(Name);
				prefix = p.getText();
				State = 132; Match(COLON);
				}
				break;
			}
			State = 135; _localctx.t = Match(Name);
			stepExpr = new Step(_interpreter, t.getText(), prefix, axisId); _contextStack.Push(stepExpr); 
			State = 140;
			_la = TokenStream.La(1);
			if (_la==L_BRACKET) {
				{
				State = 137; predicate();
				stepExpr.Qualifier = (IExpr) _stack.Pop();
				}
			}


					_contextStack.Pop();
					_stack.Push(stepExpr);
				
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BasicExpressionContext : ParserRuleContext {
		public FlwrExprContext flwrExpr() {
			return GetRuleContext<FlwrExprContext>(0);
		}
		public IfExprContext ifExpr() {
			return GetRuleContext<IfExprContext>(0);
		}
		public LogicalOrExpressionContext logicalOrExpression() {
			return GetRuleContext<LogicalOrExpressionContext>(0);
		}
		public BasicExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_basicExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterBasicExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitBasicExpression(this);
		}
	}

	[RuleVersion(0)]
	public BasicExpressionContext basicExpression() {
		BasicExpressionContext _localctx = new BasicExpressionContext(Context, State);
		EnterRule(_localctx, 16, RULE_basicExpression);
		try {
			State = 147;
			switch (TokenStream.La(1)) {
			case T__3:
			case T__5:
				EnterOuterAlt(_localctx, 1);
				{
				State = 144; flwrExpr();
				}
				break;
			case T__17:
				EnterOuterAlt(_localctx, 2);
				{
				State = 145; ifExpr();
				}
				break;
			case T__16:
			case STRING_LITERAL:
			case NUMERIC_LITERAL:
			case Name:
			case INLINE:
			case L_PAREN:
			case DEREFERENCE:
			case AT:
			case SLASH_AT:
			case SLASH:
			case SLASH_SLASH:
			case LESS_THAN:
			case MINUS:
			case DOLLAR:
				EnterOuterAlt(_localctx, 3);
				{
				State = 146; logicalOrExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PredicateContext : ParserRuleContext {
		public ITerminalNode L_BRACKET() { return GetToken(XQueryParser.L_BRACKET, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode R_BRACKET() { return GetToken(XQueryParser.R_BRACKET, 0); }
		public PredicateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predicate; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterPredicate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitPredicate(this);
		}
	}

	[RuleVersion(0)]
	public PredicateContext predicate() {
		PredicateContext _localctx = new PredicateContext(Context, State);
		EnterRule(_localctx, 18, RULE_predicate);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 149; Match(L_BRACKET);
			State = 150; expression();
			State = 151; Match(R_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableContext : ParserRuleContext {
		public bool isDef;
		public IToken t;
		public ITerminalNode DOLLAR() { return GetToken(XQueryParser.DOLLAR, 0); }
		public ITerminalNode Name() { return GetToken(XQueryParser.Name, 0); }
		public VariableContext(ParserRuleContext parent, int invokingState) : base(parent, invokingState) { }
		public VariableContext(ParserRuleContext parent, int invokingState, bool isDef)
			: base(parent, invokingState)
		{
			this.isDef = isDef;
		}
		public override int RuleIndex { get { return RULE_variable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterVariable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitVariable(this);
		}
	}

	[RuleVersion(0)]
	public VariableContext variable(bool isDef) {
		VariableContext _localctx = new VariableContext(Context, State, isDef);
		EnterRule(_localctx, 20, RULE_variable);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 153; Match(DOLLAR);
			State = 154; _localctx.t = Match(Name);

				_stack.Push(new Ident(_interpreter, t.getText(), isDef));

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlwrExprContext : ParserRuleContext {
		public FlClauseContext flClause() {
			return GetRuleContext<FlClauseContext>(0);
		}
		public PrimitiveExpressionContext primitiveExpression() {
			return GetRuleContext<PrimitiveExpressionContext>(0);
		}
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public SortByClauseContext sortByClause() {
			return GetRuleContext<SortByClauseContext>(0);
		}
		public FlwrExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flwrExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterFlwrExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitFlwrExpr(this);
		}
	}

	[RuleVersion(0)]
	public FlwrExprContext flwrExpr() {
		FlwrExprContext _localctx = new FlwrExprContext(Context, State);
		EnterRule(_localctx, 22, RULE_flwrExpr);

			IExpr where = null;
			bool hasWhere = false;
			IExpr sortby = null;
			bool hasSortby = false;
			
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 157; flClause();
			State = 161;
			_la = TokenStream.La(1);
			if (_la==T__6) {
				{
				State = 158; whereClause();
				hasWhere = true;
				}
			}

			State = 163; Match(T__2);
			State = 164; primitiveExpression();
			State = 168;
			_la = TokenStream.La(1);
			if (_la==T__7) {
				{
				State = 165; sortByClause();
				 hasSortby = true;
				}
			}


					if (hasSortby)
					{
						sortby = (IExpr) _stack.Pop();
					}
					
					IExpr returnExpr = (IExpr) _stack.Pop();
					
					if (hasWhere)
					{
						where = (IExpr) _stack.Pop();
					}
					
					IExpr fl = (IExpr) _stack.Pop();
					
					_stack.Push(new Flwr(_interpreter, fl, where, returnExpr, sortby));
				
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FlClauseContext : ParserRuleContext {
		public ForClauseContext[] forClause() {
			return GetRuleContexts<ForClauseContext>();
		}
		public ForClauseContext forClause(int i) {
			return GetRuleContext<ForClauseContext>(i);
		}
		public LetClauseContext[] letClause() {
			return GetRuleContexts<LetClauseContext>();
		}
		public LetClauseContext letClause(int i) {
			return GetRuleContext<LetClauseContext>(i);
		}
		public FlClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterFlClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitFlClause(this);
		}
	}

	[RuleVersion(0)]
	public FlClauseContext flClause() {
		FlClauseContext _localctx = new FlClauseContext(Context, State);
		EnterRule(_localctx, 24, RULE_flClause);

			int depth = _stack.Count;
			FLClause fl = new FLClause(_interpreter);
			
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 174;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			do {
				{
				State = 174;
				switch (TokenStream.La(1)) {
				case T__3:
					{
					State = 172; forClause();
					}
					break;
				case T__5:
					{
					State = 173; letClause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 176;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			} while ( _la==T__3 || _la==T__5 );

					IExpr expr = null;
					if (_stack.Count > depth)
					{
						while (_stack.Count > depth)
						{
							expr = (IExpr) _stack.Pop();
							fl.InsertExpr(0, expr);
						}
						_stack.Push(fl);
					}		
				
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForClauseContext : ParserRuleContext {
		public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ForClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterForClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitForClause(this);
		}
	}

	[RuleVersion(0)]
	public ForClauseContext forClause() {
		ForClauseContext _localctx = new ForClauseContext(Context, State);
		EnterRule(_localctx, 26, RULE_forClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 180; Match(T__3);
			State = 181; variable(true);
			State = 182; Match(T__4);
			State = 183; expression();

					IExpr expr = (IExpr) _stack.Pop();
					IExpr var = (IExpr) _stack.Pop();
					_stack.Push(new For(_interpreter, var, expr));
			   
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LetClauseContext : ParserRuleContext {
		public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		public ITerminalNode SET_EQUAL_TO() { return GetToken(XQueryParser.SET_EQUAL_TO, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public LetClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_letClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterLetClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitLetClause(this);
		}
	}

	[RuleVersion(0)]
	public LetClauseContext letClause() {
		LetClauseContext _localctx = new LetClauseContext(Context, State);
		EnterRule(_localctx, 28, RULE_letClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 186; Match(T__5);
			State = 187; variable(true);
			State = 188; Match(SET_EQUAL_TO);
			State = 189; expression();

					IExpr expr = (IExpr) _stack.Pop();
					IExpr var = (IExpr) _stack.Pop();
					_stack.Push(new Let(_interpreter, var, expr));
				
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhereClauseContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public WhereClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whereClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterWhereClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitWhereClause(this);
		}
	}

	[RuleVersion(0)]
	public WhereClauseContext whereClause() {
		WhereClauseContext _localctx = new WhereClauseContext(Context, State);
		EnterRule(_localctx, 30, RULE_whereClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 192; Match(T__6);
			State = 193; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SortByClauseContext : ParserRuleContext {
		public ITerminalNode L_PAREN() { return GetToken(XQueryParser.L_PAREN, 0); }
		public SortSpecListContext sortSpecList() {
			return GetRuleContext<SortSpecListContext>(0);
		}
		public ITerminalNode R_PAREN() { return GetToken(XQueryParser.R_PAREN, 0); }
		public SortByClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sortByClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterSortByClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitSortByClause(this);
		}
	}

	[RuleVersion(0)]
	public SortByClauseContext sortByClause() {
		SortByClauseContext _localctx = new SortByClauseContext(Context, State);
		EnterRule(_localctx, 32, RULE_sortByClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 195; Match(T__7);
			State = 196; Match(L_PAREN);
			State = 197; sortSpecList();
			State = 198; Match(R_PAREN);

					ExprCollection sortbySpecs = (ExprCollection) _stack.Pop();
					_stack.Push(new Sortby(_interpreter, sortbySpecs));
			    
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SortSpecListContext : ParserRuleContext {
		public SortSpecContext[] sortSpec() {
			return GetRuleContexts<SortSpecContext>();
		}
		public SortSpecContext sortSpec(int i) {
			return GetRuleContext<SortSpecContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(XQueryParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(XQueryParser.COMMA, i);
		}
		public SortSpecListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sortSpecList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterSortSpecList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitSortSpecList(this);
		}
	}

	[RuleVersion(0)]
	public SortSpecListContext sortSpecList() {
		SortSpecListContext _localctx = new SortSpecListContext(Context, State);
		EnterRule(_localctx, 34, RULE_sortSpecList);

			int depth = _stack.Count;
			ExprCollection sortSpecs = new ExprCollection();
			
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 201; sortSpec();
			State = 206;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 202; Match(COMMA);
				State = 203; sortSpec();
				}
				}
				State = 208;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}

					IExpr spec = null;
					if (_stack.Count > depth)
					{
						while (_stack.Count > depth)
						{
							spec = (IExpr) _stack.Pop();
							sortSpecs.Insert(0, spec);
						}
						_stack.Push(sortSpecs);
					}		
				
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SortSpecContext : ParserRuleContext {
		public PathExpressionContext pathExpression() {
			return GetRuleContext<PathExpressionContext>(0);
		}
		public SortSpecContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sortSpec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterSortSpec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitSortSpec(this);
		}
	}

	[RuleVersion(0)]
	public SortSpecContext sortSpec() {
		SortSpecContext _localctx = new SortSpecContext(Context, State);
		EnterRule(_localctx, 36, RULE_sortSpec);

			bool isAscending = true;
			
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 211; pathExpression();
			State = 215;
			switch (TokenStream.La(1)) {
			case T__8:
				{
				State = 212; Match(T__8);
				}
				break;
			case T__9:
				{
				State = 213; Match(T__9);
				isAscending=false;
				}
				break;
			case R_PAREN:
			case COMMA:
				break;
			default:
				throw new NoViableAltException(this);
			}

					IExpr path = (IExpr) _stack.Pop();
					_stack.Push(new SortbySpec(_interpreter, path, isAscending));
				
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LogicalOrExpressionContext : ParserRuleContext {
		public LogicalAndExpressionContext[] logicalAndExpression() {
			return GetRuleContexts<LogicalAndExpressionContext>();
		}
		public LogicalAndExpressionContext logicalAndExpression(int i) {
			return GetRuleContext<LogicalAndExpressionContext>(i);
		}
		public LogicalOrExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logicalOrExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterLogicalOrExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitLogicalOrExpression(this);
		}
	}

	[RuleVersion(0)]
	public LogicalOrExpressionContext logicalOrExpression() {
		LogicalOrExpressionContext _localctx = new LogicalOrExpressionContext(Context, State);
		EnterRule(_localctx, 38, RULE_logicalOrExpression);

			bool isLogicalOr = false;
			int depth = _stack.Count;
			
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 219; logicalAndExpression();
			State = 225;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==T__10) {
				{
				{
				State = 220; Match(T__10);
				isLogicalOr = true;
				State = 222; logicalAndExpression();
				}
				}
				State = 227;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}

					if (isLogicalOr)
					{
						IExpr left, right;
						right = (IExpr) _stack.Pop();
						left = (IExpr) _stack.Pop();
						right = new Or(_interpreter, left, right);
						while (_stack.Count > depth)
						{
							left = (IExpr) _stack.Pop();
							right = new Or(_interpreter, left, right);
						}
						
						_stack.Push(right);
					}		
				
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LogicalAndExpressionContext : ParserRuleContext {
		public RangeExpressionContext[] rangeExpression() {
			return GetRuleContexts<RangeExpressionContext>();
		}
		public RangeExpressionContext rangeExpression(int i) {
			return GetRuleContext<RangeExpressionContext>(i);
		}
		public LogicalAndExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logicalAndExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterLogicalAndExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitLogicalAndExpression(this);
		}
	}

	[RuleVersion(0)]
	public LogicalAndExpressionContext logicalAndExpression() {
		LogicalAndExpressionContext _localctx = new LogicalAndExpressionContext(Context, State);
		EnterRule(_localctx, 40, RULE_logicalAndExpression);

			bool isLogicalAnd = false;
			int depth = _stack.Count;
			
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 230; rangeExpression();
			State = 236;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==T__11) {
				{
				{
				State = 231; Match(T__11);
				isLogicalAnd = true;
				State = 233; rangeExpression();
				}
				}
				State = 238;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}

					if (isLogicalAnd)
					{
						IExpr left, right;
						right = (IExpr) _stack.Pop();
						left = (IExpr) _stack.Pop();
						right = new And(_interpreter, left, right);
						while (_stack.Count > depth)
						{
							left = (IExpr) _stack.Pop();
							right = new And(_interpreter, left, right);
						}
						
						_stack.Push(right);
					}		
				
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RangeExpressionContext : ParserRuleContext {
		public EqualityExpressionContext[] equalityExpression() {
			return GetRuleContexts<EqualityExpressionContext>();
		}
		public EqualityExpressionContext equalityExpression(int i) {
			return GetRuleContext<EqualityExpressionContext>(i);
		}
		public RangeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rangeExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterRangeExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitRangeExpression(this);
		}
	}

	[RuleVersion(0)]
	public RangeExpressionContext rangeExpression() {
		RangeExpressionContext _localctx = new RangeExpressionContext(Context, State);
		EnterRule(_localctx, 42, RULE_rangeExpression);

			bool isRange = false;
			
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 241; equalityExpression();
			State = 245;
			_la = TokenStream.La(1);
			if (_la==T__12) {
				{
				State = 242; Match(T__12);
				isRange = true;
				State = 244; equalityExpression();
				}
			}


					if (isRange)
					{
						IExpr left, right;
						right = (IExpr) _stack.Pop();
						left = (IExpr) _stack.Pop();
						_stack.Push(new To(_interpreter, left, right));
					}		
				
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EqualityExpressionContext : ParserRuleContext {
		public RelationalExpressionContext[] relationalExpression() {
			return GetRuleContexts<RelationalExpressionContext>();
		}
		public RelationalExpressionContext relationalExpression(int i) {
			return GetRuleContext<RelationalExpressionContext>(i);
		}
		public ITerminalNode[] NOT_EQUALS() { return GetTokens(XQueryParser.NOT_EQUALS); }
		public ITerminalNode NOT_EQUALS(int i) {
			return GetToken(XQueryParser.NOT_EQUALS, i);
		}
		public ITerminalNode[] EQUALS() { return GetTokens(XQueryParser.EQUALS); }
		public ITerminalNode EQUALS(int i) {
			return GetToken(XQueryParser.EQUALS, i);
		}
		public EqualityExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_equalityExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterEqualityExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitEqualityExpression(this);
		}
	}

	[RuleVersion(0)]
	public EqualityExpressionContext equalityExpression() {
		EqualityExpressionContext _localctx = new EqualityExpressionContext(Context, State);
		EnterRule(_localctx, 44, RULE_equalityExpression);

			bool isEquality = false;
			int type = 0;
			
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 249; relationalExpression();
			State = 259;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==EQUALS || _la==NOT_EQUALS) {
				{
				{
				State = 254;
				switch (TokenStream.La(1)) {
				case NOT_EQUALS:
					{
					State = 250; Match(NOT_EQUALS);
					isEquality = true;
					}
					break;
				case EQUALS:
					{
					State = 252; Match(EQUALS);
					isEquality = true; type = 1;
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 256; relationalExpression();
				}
				}
				State = 261;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}

					if (isEquality)
					{
						IExpr left, right;
						right = (IExpr) _stack.Pop();
						left = (IExpr) _stack.Pop();
						switch(type)
						{
							case 0:
								_stack.Push(new NotEquals(_interpreter, left, right));
								break;
							case 1:
								_stack.Push(new Equals(_interpreter, left, right));
								break;
						}				
					}	
				
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RelationalExpressionContext : ParserRuleContext {
		public AdditiveExpressionContext[] additiveExpression() {
			return GetRuleContexts<AdditiveExpressionContext>();
		}
		public AdditiveExpressionContext additiveExpression(int i) {
			return GetRuleContext<AdditiveExpressionContext>(i);
		}
		public ITerminalNode[] LESS_THAN() { return GetTokens(XQueryParser.LESS_THAN); }
		public ITerminalNode LESS_THAN(int i) {
			return GetToken(XQueryParser.LESS_THAN, i);
		}
		public ITerminalNode[] GREATER_THAN() { return GetTokens(XQueryParser.GREATER_THAN); }
		public ITerminalNode GREATER_THAN(int i) {
			return GetToken(XQueryParser.GREATER_THAN, i);
		}
		public ITerminalNode[] LESS_THAN_EQUALS() { return GetTokens(XQueryParser.LESS_THAN_EQUALS); }
		public ITerminalNode LESS_THAN_EQUALS(int i) {
			return GetToken(XQueryParser.LESS_THAN_EQUALS, i);
		}
		public ITerminalNode[] GREATER_THAN_EQUALS() { return GetTokens(XQueryParser.GREATER_THAN_EQUALS); }
		public ITerminalNode GREATER_THAN_EQUALS(int i) {
			return GetToken(XQueryParser.GREATER_THAN_EQUALS, i);
		}
		public RelationalExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relationalExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterRelationalExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitRelationalExpression(this);
		}
	}

	[RuleVersion(0)]
	public RelationalExpressionContext relationalExpression() {
		RelationalExpressionContext _localctx = new RelationalExpressionContext(Context, State);
		EnterRule(_localctx, 46, RULE_relationalExpression);

			bool isRelational = false;
			int type = 0;
			
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 264; additiveExpression();
			State = 284;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__4) | (1L << T__13) | (1L << T__14) | (1L << LESS_THAN) | (1L << GREATER_THAN) | (1L << LESS_THAN_EQUALS) | (1L << GREATER_THAN_EQUALS))) != 0)) {
				{
				{
				State = 279;
				switch (TokenStream.La(1)) {
				case LESS_THAN:
					{
					State = 265; Match(LESS_THAN);
					isRelational = true;
					}
					break;
				case GREATER_THAN:
					{
					State = 267; Match(GREATER_THAN);
					isRelational = true; type = 1;
					}
					break;
				case LESS_THAN_EQUALS:
					{
					State = 269; Match(LESS_THAN_EQUALS);
					isRelational = true; type = 2;
					}
					break;
				case GREATER_THAN_EQUALS:
					{
					State = 271; Match(GREATER_THAN_EQUALS);
					isRelational = true; type = 3;
					}
					break;
				case T__4:
					{
					State = 273; Match(T__4);
					isRelational = true; type = 4;
					}
					break;
				case T__13:
					{
					State = 275; Match(T__13);
					isRelational = true; type = 5;
					}
					break;
				case T__14:
					{
					State = 277; Match(T__14);
					isRelational = true; type = 6;
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 281; additiveExpression();
				}
				}
				State = 286;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}

					if (isRelational)
					{
						IExpr left, right;
						right = (IExpr) _stack.Pop();
						left = (IExpr) _stack.Pop();
						switch(type)
						{
							case 0:
								_stack.Push(new LessThan(_interpreter, left, right));
								break;
							case 1:
								_stack.Push(new GreaterThan(_interpreter, left, right));
								break;
							case 2:
								_stack.Push(new LEquals(_interpreter, left, right));
								break;
							case 3:
								_stack.Push(new GEquals(_interpreter, left, right));
								break;
							case 4:
								_stack.Push(new In(_interpreter, left, right));
								break;
							case 5:
								_stack.Push(new NotIn(_interpreter, left, right));
								break;	
							case 6:
								_stack.Push(new Like(_interpreter, left, right));
								break;																				
						}				
					}	
				
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AdditiveExpressionContext : ParserRuleContext {
		public MultiplicativeExpressionContext[] multiplicativeExpression() {
			return GetRuleContexts<MultiplicativeExpressionContext>();
		}
		public MultiplicativeExpressionContext multiplicativeExpression(int i) {
			return GetRuleContext<MultiplicativeExpressionContext>(i);
		}
		public ITerminalNode[] PLUS() { return GetTokens(XQueryParser.PLUS); }
		public ITerminalNode PLUS(int i) {
			return GetToken(XQueryParser.PLUS, i);
		}
		public ITerminalNode[] MINUS() { return GetTokens(XQueryParser.MINUS); }
		public ITerminalNode MINUS(int i) {
			return GetToken(XQueryParser.MINUS, i);
		}
		public AdditiveExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_additiveExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterAdditiveExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitAdditiveExpression(this);
		}
	}

	[RuleVersion(0)]
	public AdditiveExpressionContext additiveExpression() {
		AdditiveExpressionContext _localctx = new AdditiveExpressionContext(Context, State);
		EnterRule(_localctx, 48, RULE_additiveExpression);

			bool isAdditive = false;
			int type = 0;
			
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 289; multiplicativeExpression();
			State = 299;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==PLUS || _la==MINUS) {
				{
				{
				State = 294;
				switch (TokenStream.La(1)) {
				case PLUS:
					{
					State = 290; Match(PLUS);
					isAdditive = true;
					}
					break;
				case MINUS:
					{
					State = 292; Match(MINUS);
					isAdditive = true; type = 1;
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 296; multiplicativeExpression();
				}
				}
				State = 301;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}

					if (isAdditive)
					{
						IExpr left, right;
						right = (IExpr) _stack.Pop();
						left = (IExpr) _stack.Pop();
						switch(type)
						{
							case 0:
								_stack.Push(new Plus(_interpreter, left, right));
								break;
							case 1:
								_stack.Push(new Substract(_interpreter, left, right));
								break;																			
						}				
					}
				
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiplicativeExpressionContext : ParserRuleContext {
		public UnaryExpressionContext[] unaryExpression() {
			return GetRuleContexts<UnaryExpressionContext>();
		}
		public UnaryExpressionContext unaryExpression(int i) {
			return GetRuleContext<UnaryExpressionContext>(i);
		}
		public ITerminalNode[] STAR() { return GetTokens(XQueryParser.STAR); }
		public ITerminalNode STAR(int i) {
			return GetToken(XQueryParser.STAR, i);
		}
		public ITerminalNode[] MOD() { return GetTokens(XQueryParser.MOD); }
		public ITerminalNode MOD(int i) {
			return GetToken(XQueryParser.MOD, i);
		}
		public MultiplicativeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiplicativeExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterMultiplicativeExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitMultiplicativeExpression(this);
		}
	}

	[RuleVersion(0)]
	public MultiplicativeExpressionContext multiplicativeExpression() {
		MultiplicativeExpressionContext _localctx = new MultiplicativeExpressionContext(Context, State);
		EnterRule(_localctx, 50, RULE_multiplicativeExpression);

			bool isMultiplicative = false;
			int type = 0;
			
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 304; unaryExpression();
			State = 316;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__15) | (1L << STAR) | (1L << MOD))) != 0)) {
				{
				{
				State = 311;
				switch (TokenStream.La(1)) {
				case STAR:
					{
					State = 305; Match(STAR);
					isMultiplicative = true;
					}
					break;
				case T__15:
					{
					State = 307; Match(T__15);
					isMultiplicative = true; type = 1;
					}
					break;
				case MOD:
					{
					State = 309; Match(MOD);
					isMultiplicative = true; type = 2;
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 313; unaryExpression();
				}
				}
				State = 318;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}

					if (isMultiplicative)
					{
						IExpr left, right;
						right = (IExpr) _stack.Pop();
						left = (IExpr) _stack.Pop();
						switch(type)
						{
							case 0:
								_stack.Push(new Times(_interpreter, left, right));
								break;
							case 1:
								_stack.Push(new Divide(_interpreter, left, right));
								break;
							case 2:
								_stack.Push(new Mod(_interpreter, left, right));
								break;																							
						}				
					}
				
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryExpressionContext : ParserRuleContext {
		public ITerminalNode MINUS() { return GetToken(XQueryParser.MINUS, 0); }
		public UnaryExpressionContext unaryExpression() {
			return GetRuleContext<UnaryExpressionContext>(0);
		}
		public PrimitiveExpressionContext primitiveExpression() {
			return GetRuleContext<PrimitiveExpressionContext>(0);
		}
		public UnaryExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterUnaryExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitUnaryExpression(this);
		}
	}

	[RuleVersion(0)]
	public UnaryExpressionContext unaryExpression() {
		UnaryExpressionContext _localctx = new UnaryExpressionContext(Context, State);
		EnterRule(_localctx, 52, RULE_unaryExpression);
		try {
			State = 326;
			switch (TokenStream.La(1)) {
			case MINUS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 321; Match(MINUS);
				State = 322; unaryExpression();

							IExpr expr = (IExpr) _stack.Pop();
							_stack.Push(new UMinus(_interpreter, expr));
						
				}
				break;
			case T__16:
			case STRING_LITERAL:
			case NUMERIC_LITERAL:
			case Name:
			case INLINE:
			case L_PAREN:
			case DEREFERENCE:
			case AT:
			case SLASH_AT:
			case SLASH:
			case SLASH_SLASH:
			case LESS_THAN:
			case DOLLAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 325; primitiveExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrimitiveExpressionContext : ParserRuleContext {
		public IToken t1;
		public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public ITerminalNode INLINE() { return GetToken(XQueryParser.INLINE, 0); }
		public ElementConstructorContext elementConstructor() {
			return GetRuleContext<ElementConstructorContext>(0);
		}
		public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		public ITerminalNode L_PAREN() { return GetToken(XQueryParser.L_PAREN, 0); }
		public ExprSequenceContext exprSequence() {
			return GetRuleContext<ExprSequenceContext>(0);
		}
		public ITerminalNode R_PAREN() { return GetToken(XQueryParser.R_PAREN, 0); }
		public PathExpressionContext pathExpression() {
			return GetRuleContext<PathExpressionContext>(0);
		}
		public PrimitiveExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_primitiveExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterPrimitiveExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitPrimitiveExpression(this);
		}
	}

	[RuleVersion(0)]
	public PrimitiveExpressionContext primitiveExpression() {
		PrimitiveExpressionContext _localctx = new PrimitiveExpressionContext(Context, State);
		EnterRule(_localctx, 54, RULE_primitiveExpression);
		try {
			State = 342;
			switch ( Interpreter.AdaptivePredict(TokenStream,26,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 328; literal();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 329; Match(T__16);
				 _stack.Push(new Null(_interpreter)); 
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 331; _localctx.t1 = Match(INLINE);
				 _stack.Push(new InlineXml(_interpreter, t1.getText())); 
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 333; elementConstructor();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 334; functionCall();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 335; variable(false);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 336; Match(L_PAREN);
				State = 337; exprSequence();
				State = 338; Match(R_PAREN);
				 IExpr expr = (IExpr) _stack.Pop(); _stack.Push(new ParenthesizedExpr(_interpreter, expr)); 
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 341; pathExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionCallContext : ParserRuleContext {
		public IToken t;
		public ITerminalNode L_PAREN() { return GetToken(XQueryParser.L_PAREN, 0); }
		public ITerminalNode R_PAREN() { return GetToken(XQueryParser.R_PAREN, 0); }
		public ITerminalNode Name() { return GetToken(XQueryParser.Name, 0); }
		public ExprSequenceContext exprSequence() {
			return GetRuleContext<ExprSequenceContext>(0);
		}
		public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionCall; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}
	}

	[RuleVersion(0)]
	public FunctionCallContext functionCall() {
		FunctionCallContext _localctx = new FunctionCallContext(Context, State);
		EnterRule(_localctx, 56, RULE_functionCall);

			bool hasArguments = false;
			
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 344; _localctx.t = Match(Name);
			State = 345; Match(L_PAREN);
			State = 349;
			_la = TokenStream.La(1);
			if (((((_la - 4)) & ~0x3f) == 0 && ((1L << (_la - 4)) & ((1L << (T__3 - 4)) | (1L << (T__5 - 4)) | (1L << (T__16 - 4)) | (1L << (T__17 - 4)) | (1L << (STRING_LITERAL - 4)) | (1L << (NUMERIC_LITERAL - 4)) | (1L << (Name - 4)) | (1L << (INLINE - 4)) | (1L << (L_PAREN - 4)) | (1L << (DEREFERENCE - 4)) | (1L << (AT - 4)) | (1L << (SLASH_AT - 4)) | (1L << (SLASH - 4)) | (1L << (SLASH_SLASH - 4)) | (1L << (LESS_THAN - 4)) | (1L << (MINUS - 4)) | (1L << (DOLLAR - 4)))) != 0)) {
				{
				State = 346; exprSequence();
				hasArguments = true;
				}
			}

			State = 351; Match(R_PAREN);

					ExprCollection arguments = null;
					if (hasArguments)
					{
						arguments = (ExprCollection) _stack.Pop();
					}
					
					_stack.Push(new FunctionCall(_interpreter, t.getText(), arguments));
				
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		public IToken t1;
		public IToken t2;
		public ITerminalNode NUMERIC_LITERAL() { return GetToken(XQueryParser.NUMERIC_LITERAL, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(XQueryParser.STRING_LITERAL, 0); }
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitLiteral(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(Context, State);
		EnterRule(_localctx, 58, RULE_literal);
		try {
			State = 358;
			switch (TokenStream.La(1)) {
			case NUMERIC_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 354; _localctx.t1 = Match(NUMERIC_LITERAL);
				 _stack.Push(new Literal(_interpreter, t1.getText()));
				}
				break;
			case STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 356; _localctx.t2 = Match(STRING_LITERAL);
				 _stack.Push(new Literal(_interpreter, new StringType(), new XString(t2.getText())));
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfExprContext : ParserRuleContext {
		public ITerminalNode L_PAREN() { return GetToken(XQueryParser.L_PAREN, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode R_PAREN() { return GetToken(XQueryParser.R_PAREN, 0); }
		public IfExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterIfExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitIfExpr(this);
		}
	}

	[RuleVersion(0)]
	public IfExprContext ifExpr() {
		IfExprContext _localctx = new IfExprContext(Context, State);
		EnterRule(_localctx, 60, RULE_ifExpr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 360; Match(T__17);
			State = 361; Match(L_PAREN);
			State = 362; expression();
			State = 363; Match(R_PAREN);
			State = 364; Match(T__18);
			State = 365; expression();
			State = 366; Match(T__19);
			State = 367; expression();

					IExpr elseClause = (IExpr) _stack.Pop();
					IExpr thenClause = (IExpr) _stack.Pop();
					IExpr condition = (IExpr) _stack.Pop();
					_stack.Push(new If(_interpreter, condition, thenClause, elseClause));
				
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementConstructorContext : ParserRuleContext {
		public IToken t;
		public ITerminalNode LESS_THAN() { return GetToken(XQueryParser.LESS_THAN, 0); }
		public ITerminalNode[] GREATER_THAN() { return GetTokens(XQueryParser.GREATER_THAN); }
		public ITerminalNode GREATER_THAN(int i) {
			return GetToken(XQueryParser.GREATER_THAN, i);
		}
		public ElementContentsContext elementContents() {
			return GetRuleContext<ElementContentsContext>(0);
		}
		public ITerminalNode LESS_THAN_SLASH() { return GetToken(XQueryParser.LESS_THAN_SLASH, 0); }
		public ITerminalNode[] Name() { return GetTokens(XQueryParser.Name); }
		public ITerminalNode Name(int i) {
			return GetToken(XQueryParser.Name, i);
		}
		public AttributeContext[] attribute() {
			return GetRuleContexts<AttributeContext>();
		}
		public AttributeContext attribute(int i) {
			return GetRuleContext<AttributeContext>(i);
		}
		public ElementConstructorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elementConstructor; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterElementConstructor(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitElementConstructor(this);
		}
	}

	[RuleVersion(0)]
	public ElementConstructorContext elementConstructor() {
		ElementConstructorContext _localctx = new ElementConstructorContext(Context, State);
		EnterRule(_localctx, 62, RULE_elementConstructor);

			int depth = _stack.Count;
			ExprCollection attributes = null;
			
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 370; Match(LESS_THAN);
			State = 371; _localctx.t = Match(Name);
			State = 375;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==Name || _la==L_BRACE) {
				{
				{
				State = 372; attribute();
				}
				}
				State = 377;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 378; Match(GREATER_THAN);
			State = 379; elementContents();
			State = 380; Match(LESS_THAN_SLASH);
			State = 381; Match(Name);
			State = 382; Match(GREATER_THAN);

					IExpr content = (IExpr) _stack.Pop();

					if (_stack.Count > depth)
					{
						IExpr attr;
						attributes = new ExprCollection();
						while (_stack.Count > depth)
						{
							attr = (IExpr) _stack.Pop();
							attributes.Insert(0, attr);
						}
					}
					
					_stack.Push(new ElementNode(_interpreter, t.getText(), attributes, content));
				
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementContentsContext : ParserRuleContext {
		public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public ElementConstructorContext[] elementConstructor() {
			return GetRuleContexts<ElementConstructorContext>();
		}
		public ElementConstructorContext elementConstructor(int i) {
			return GetRuleContext<ElementConstructorContext>(i);
		}
		public EnclosedExprContext[] enclosedExpr() {
			return GetRuleContexts<EnclosedExprContext>();
		}
		public EnclosedExprContext enclosedExpr(int i) {
			return GetRuleContext<EnclosedExprContext>(i);
		}
		public ElementContentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elementContents; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterElementContents(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitElementContents(this);
		}
	}

	[RuleVersion(0)]
	public ElementContentsContext elementContents() {
		ElementContentsContext _localctx = new ElementContentsContext(Context, State);
		EnterRule(_localctx, 64, RULE_elementContents);

			int depth = _stack.Count;
			
		int _la;
		try {
			State = 394;
			switch (TokenStream.La(1)) {
			case STRING_LITERAL:
			case NUMERIC_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 385; literal();
				}
				break;
			case L_BRACE:
			case LESS_THAN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 388;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				do {
					{
					State = 388;
					switch (TokenStream.La(1)) {
					case LESS_THAN:
						{
						State = 386; elementConstructor();
						}
						break;
					case L_BRACE:
						{
						State = 387; enclosedExpr();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					State = 390;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				} while ( _la==L_BRACE || _la==LESS_THAN );

							IExpr expr = null;
							if (_stack.Count > depth)
							{
								ExprCollection exprs = new ExprCollection();
								while (_stack.Count > depth)
								{
									expr = (IExpr) _stack.Pop();
									exprs.Insert(0, expr);
								}
								_stack.Push(exprs);
							}
						
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AttributeContext : ParserRuleContext {
		public IToken t;
		public ITerminalNode EQUALS() { return GetToken(XQueryParser.EQUALS, 0); }
		public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public ITerminalNode Name() { return GetToken(XQueryParser.Name, 0); }
		public EnclosedExprContext enclosedExpr() {
			return GetRuleContext<EnclosedExprContext>(0);
		}
		public AttributeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attribute; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterAttribute(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitAttribute(this);
		}
	}

	[RuleVersion(0)]
	public AttributeContext attribute() {
		AttributeContext _localctx = new AttributeContext(Context, State);
		EnterRule(_localctx, 66, RULE_attribute);
		try {
			State = 402;
			switch (TokenStream.La(1)) {
			case Name:
				EnterOuterAlt(_localctx, 1);
				{
				State = 396; _localctx.t = Match(Name);
				State = 397; Match(EQUALS);
				State = 398; literal();

						IExpr attrValue = (IExpr) _stack.Pop();
						_stack.Push(new AttributeNode(_interpreter, t.getText(), attrValue));
					
				}
				break;
			case L_BRACE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 401; enclosedExpr();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnclosedExprContext : ParserRuleContext {
		public ITerminalNode L_BRACE() { return GetToken(XQueryParser.L_BRACE, 0); }
		public ExprSequenceContext exprSequence() {
			return GetRuleContext<ExprSequenceContext>(0);
		}
		public ITerminalNode R_BRACE() { return GetToken(XQueryParser.R_BRACE, 0); }
		public EnclosedExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enclosedExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.EnterEnclosedExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXQueryListener typedListener = listener as IXQueryListener;
			if (typedListener != null) typedListener.ExitEnclosedExpr(this);
		}
	}

	[RuleVersion(0)]
	public EnclosedExprContext enclosedExpr() {
		EnclosedExprContext _localctx = new EnclosedExprContext(Context, State);
		EnterRule(_localctx, 68, RULE_enclosedExpr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 404; Match(L_BRACE);
			State = 405; exprSequence();
			State = 406; Match(R_BRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public static readonly string _serializedATN =
		"\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3\x43\x19B\x4\x2\t"+
		"\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t"+
		"\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B"+
		"\t\x1B\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t \x4!"+
		"\t!\x4\"\t\"\x4#\t#\x4$\t$\x3\x2\x3\x2\x3\x2\x3\x3\a\x3M\n\x3\f\x3\xE"+
		"\x3P\v\x3\x3\x3\x3\x3\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x5\x3\x5\x3\x5"+
		"\a\x5\\\n\x5\f\x5\xE\x5_\v\x5\x3\x5\x3\x5\x3\x6\x3\x6\x3\a\x3\a\x3\a\x3"+
		"\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x5\ap\n\a\x3\b\x6\bs\n\b\r\b\xE"+
		"\bt\x3\b\x3\b\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x5\t\x83"+
		"\n\t\x3\t\x3\t\x3\t\x5\t\x88\n\t\x3\t\x3\t\x3\t\x3\t\x3\t\x5\t\x8F\n\t"+
		"\x3\t\x3\t\x3\n\x3\n\x3\n\x5\n\x96\n\n\x3\v\x3\v\x3\v\x3\v\x3\f\x3\f\x3"+
		"\f\x3\f\x3\r\x3\r\x3\r\x3\r\x5\r\xA4\n\r\x3\r\x3\r\x3\r\x3\r\x3\r\x5\r"+
		"\xAB\n\r\x3\r\x3\r\x3\xE\x3\xE\x6\xE\xB1\n\xE\r\xE\xE\xE\xB2\x3\xE\x3"+
		"\xE\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\x10\x3\x10\x3\x10\x3\x10\x3"+
		"\x10\x3\x10\x3\x11\x3\x11\x3\x11\x3\x12\x3\x12\x3\x12\x3\x12\x3\x12\x3"+
		"\x12\x3\x13\x3\x13\x3\x13\a\x13\xCF\n\x13\f\x13\xE\x13\xD2\v\x13\x3\x13"+
		"\x3\x13\x3\x14\x3\x14\x3\x14\x3\x14\x5\x14\xDA\n\x14\x3\x14\x3\x14\x3"+
		"\x15\x3\x15\x3\x15\x3\x15\a\x15\xE2\n\x15\f\x15\xE\x15\xE5\v\x15\x3\x15"+
		"\x3\x15\x3\x16\x3\x16\x3\x16\x3\x16\a\x16\xED\n\x16\f\x16\xE\x16\xF0\v"+
		"\x16\x3\x16\x3\x16\x3\x17\x3\x17\x3\x17\x3\x17\x5\x17\xF8\n\x17\x3\x17"+
		"\x3\x17\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x5\x18\x101\n\x18\x3\x18\a"+
		"\x18\x104\n\x18\f\x18\xE\x18\x107\v\x18\x3\x18\x3\x18\x3\x19\x3\x19\x3"+
		"\x19\x3\x19\x3\x19\x3\x19\x3\x19\x3\x19\x3\x19\x3\x19\x3\x19\x3\x19\x3"+
		"\x19\x3\x19\x3\x19\x5\x19\x11A\n\x19\x3\x19\a\x19\x11D\n\x19\f\x19\xE"+
		"\x19\x120\v\x19\x3\x19\x3\x19\x3\x1A\x3\x1A\x3\x1A\x3\x1A\x3\x1A\x5\x1A"+
		"\x129\n\x1A\x3\x1A\a\x1A\x12C\n\x1A\f\x1A\xE\x1A\x12F\v\x1A\x3\x1A\x3"+
		"\x1A\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x5\x1B\x13A\n\x1B"+
		"\x3\x1B\a\x1B\x13D\n\x1B\f\x1B\xE\x1B\x140\v\x1B\x3\x1B\x3\x1B\x3\x1C"+
		"\x3\x1C\x3\x1C\x3\x1C\x3\x1C\x5\x1C\x149\n\x1C\x3\x1D\x3\x1D\x3\x1D\x3"+
		"\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3"+
		"\x1D\x5\x1D\x159\n\x1D\x3\x1E\x3\x1E\x3\x1E\x3\x1E\x3\x1E\x5\x1E\x160"+
		"\n\x1E\x3\x1E\x3\x1E\x3\x1E\x3\x1F\x3\x1F\x3\x1F\x3\x1F\x5\x1F\x169\n"+
		"\x1F\x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3!\x3!\x3!\a!\x178\n!\f"+
		"!\xE!\x17B\v!\x3!\x3!\x3!\x3!\x3!\x3!\x3!\x3\"\x3\"\x3\"\x6\"\x187\n\""+
		"\r\"\xE\"\x188\x3\"\x3\"\x5\"\x18D\n\"\x3#\x3#\x3#\x3#\x3#\x3#\x5#\x195"+
		"\n#\x3$\x3$\x3$\x3$\x3$\x2\x2%\x2\x4\x6\b\n\f\xE\x10\x12\x14\x16\x18\x1A"+
		"\x1C\x1E \"$&(*,.\x30\x32\x34\x36\x38:<>@\x42\x44\x46\x2\x2\x1AC\x2H\x3"+
		"\x2\x2\x2\x4N\x3\x2\x2\x2\x6S\x3\x2\x2\x2\bX\x3\x2\x2\x2\n\x62\x3\x2\x2"+
		"\x2\fo\x3\x2\x2\x2\xEr\x3\x2\x2\x2\x10\x82\x3\x2\x2\x2\x12\x95\x3\x2\x2"+
		"\x2\x14\x97\x3\x2\x2\x2\x16\x9B\x3\x2\x2\x2\x18\x9F\x3\x2\x2\x2\x1A\xB0"+
		"\x3\x2\x2\x2\x1C\xB6\x3\x2\x2\x2\x1E\xBC\x3\x2\x2\x2 \xC2\x3\x2\x2\x2"+
		"\"\xC5\x3\x2\x2\x2$\xCB\x3\x2\x2\x2&\xD5\x3\x2\x2\x2(\xDD\x3\x2\x2\x2"+
		"*\xE8\x3\x2\x2\x2,\xF3\x3\x2\x2\x2.\xFB\x3\x2\x2\x2\x30\x10A\x3\x2\x2"+
		"\x2\x32\x123\x3\x2\x2\x2\x34\x132\x3\x2\x2\x2\x36\x148\x3\x2\x2\x2\x38"+
		"\x158\x3\x2\x2\x2:\x15A\x3\x2\x2\x2<\x168\x3\x2\x2\x2>\x16A\x3\x2\x2\x2"+
		"@\x174\x3\x2\x2\x2\x42\x18C\x3\x2\x2\x2\x44\x194\x3\x2\x2\x2\x46\x196"+
		"\x3\x2\x2\x2HI\x5\x4\x3\x2IJ\b\x2\x1\x2J\x3\x3\x2\x2\x2KM\x5\x6\x4\x2"+
		"LK\x3\x2\x2\x2MP\x3\x2\x2\x2NL\x3\x2\x2\x2NO\x3\x2\x2\x2OQ\x3\x2\x2\x2"+
		"PN\x3\x2\x2\x2QR\x5\n\x6\x2R\x5\x3\x2\x2\x2ST\a\x3\x2\x2TU\a\x1A\x2\x2"+
		"UV\a\x4\x2\x2VW\a\x1A\x2\x2W\a\x3\x2\x2\x2X]\x5\n\x6\x2YZ\a$\x2\x2Z\\"+
		"\x5\n\x6\x2[Y\x3\x2\x2\x2\\_\x3\x2\x2\x2][\x3\x2\x2\x2]^\x3\x2\x2\x2^"+
		"`\x3\x2\x2\x2_]\x3\x2\x2\x2`\x61\b\x5\x1\x2\x61\t\x3\x2\x2\x2\x62\x63"+
		"\x5\x12\n\x2\x63\v\x3\x2\x2\x2\x64\x65\x5\x16\f\x2\x65\x66\x5\xE\b\x2"+
		"\x66g\b\a\x1\x2gp\x3\x2\x2\x2hi\x5:\x1E\x2ij\x5\xE\b\x2jk\b\a\x1\x2kp"+
		"\x3\x2\x2\x2lm\x5\xE\b\x2mn\b\a\x1\x2np\x3\x2\x2\x2o\x64\x3\x2\x2\x2o"+
		"h\x3\x2\x2\x2ol\x3\x2\x2\x2p\r\x3\x2\x2\x2qs\x5\x10\t\x2rq\x3\x2\x2\x2"+
		"st\x3\x2\x2\x2tr\x3\x2\x2\x2tu\x3\x2\x2\x2uv\x3\x2\x2\x2vw\b\b\x1\x2w"+
		"\xF\x3\x2\x2\x2xy\a/\x2\x2y\x83\b\t\x1\x2z{\a\x30\x2\x2{\x83\b\t\x1\x2"+
		"|}\a-\x2\x2}\x83\b\t\x1\x2~\x7F\a+\x2\x2\x7F\x83\b\t\x1\x2\x80\x81\a,"+
		"\x2\x2\x81\x83\b\t\x1\x2\x82x\x3\x2\x2\x2\x82z\x3\x2\x2\x2\x82|\x3\x2"+
		"\x2\x2\x82~\x3\x2\x2\x2\x82\x80\x3\x2\x2\x2\x82\x83\x3\x2\x2\x2\x83\x87"+
		"\x3\x2\x2\x2\x84\x85\a\x1A\x2\x2\x85\x86\b\t\x1\x2\x86\x88\a\'\x2\x2\x87"+
		"\x84\x3\x2\x2\x2\x87\x88\x3\x2\x2\x2\x88\x89\x3\x2\x2\x2\x89\x8A\a\x1A"+
		"\x2\x2\x8A\x8E\b\t\x1\x2\x8B\x8C\x5\x14\v\x2\x8C\x8D\b\t\x1\x2\x8D\x8F"+
		"\x3\x2\x2\x2\x8E\x8B\x3\x2\x2\x2\x8E\x8F\x3\x2\x2\x2\x8F\x90\x3\x2\x2"+
		"\x2\x90\x91\b\t\x1\x2\x91\x11\x3\x2\x2\x2\x92\x96\x5\x18\r\x2\x93\x96"+
		"\x5> \x2\x94\x96\x5(\x15\x2\x95\x92\x3\x2\x2\x2\x95\x93\x3\x2\x2\x2\x95"+
		"\x94\x3\x2\x2\x2\x96\x13\x3\x2\x2\x2\x97\x98\a%\x2\x2\x98\x99\x5\n\x6"+
		"\x2\x99\x9A\a&\x2\x2\x9A\x15\x3\x2\x2\x2\x9B\x9C\a\x43\x2\x2\x9C\x9D\a"+
		"\x1A\x2\x2\x9D\x9E\b\f\x1\x2\x9E\x17\x3\x2\x2\x2\x9F\xA3\x5\x1A\xE\x2"+
		"\xA0\xA1\x5 \x11\x2\xA1\xA2\b\r\x1\x2\xA2\xA4\x3\x2\x2\x2\xA3\xA0\x3\x2"+
		"\x2\x2\xA3\xA4\x3\x2\x2\x2\xA4\xA5\x3\x2\x2\x2\xA5\xA6\a\x5\x2\x2\xA6"+
		"\xAA\x5\x38\x1D\x2\xA7\xA8\x5\"\x12\x2\xA8\xA9\b\r\x1\x2\xA9\xAB\x3\x2"+
		"\x2\x2\xAA\xA7\x3\x2\x2\x2\xAA\xAB\x3\x2\x2\x2\xAB\xAC\x3\x2\x2\x2\xAC"+
		"\xAD\b\r\x1\x2\xAD\x19\x3\x2\x2\x2\xAE\xB1\x5\x1C\xF\x2\xAF\xB1\x5\x1E"+
		"\x10\x2\xB0\xAE\x3\x2\x2\x2\xB0\xAF\x3\x2\x2\x2\xB1\xB2\x3\x2\x2\x2\xB2"+
		"\xB0\x3\x2\x2\x2\xB2\xB3\x3\x2\x2\x2\xB3\xB4\x3\x2\x2\x2\xB4\xB5\b\xE"+
		"\x1\x2\xB5\x1B\x3\x2\x2\x2\xB6\xB7\a\x6\x2\x2\xB7\xB8\x5\x16\f\x2\xB8"+
		"\xB9\a\a\x2\x2\xB9\xBA\x5\n\x6\x2\xBA\xBB\b\xF\x1\x2\xBB\x1D\x3\x2\x2"+
		"\x2\xBC\xBD\a\b\x2\x2\xBD\xBE\x5\x16\f\x2\xBE\xBF\a=\x2\x2\xBF\xC0\x5"+
		"\n\x6\x2\xC0\xC1\b\x10\x1\x2\xC1\x1F\x3\x2\x2\x2\xC2\xC3\a\t\x2\x2\xC3"+
		"\xC4\x5\n\x6\x2\xC4!\x3\x2\x2\x2\xC5\xC6\a\n\x2\x2\xC6\xC7\a\"\x2\x2\xC7"+
		"\xC8\x5$\x13\x2\xC8\xC9\a#\x2\x2\xC9\xCA\b\x12\x1\x2\xCA#\x3\x2\x2\x2"+
		"\xCB\xD0\x5&\x14\x2\xCC\xCD\a$\x2\x2\xCD\xCF\x5&\x14\x2\xCE\xCC\x3\x2"+
		"\x2\x2\xCF\xD2\x3\x2\x2\x2\xD0\xCE\x3\x2\x2\x2\xD0\xD1\x3\x2\x2\x2\xD1"+
		"\xD3\x3\x2\x2\x2\xD2\xD0\x3\x2\x2\x2\xD3\xD4\b\x13\x1\x2\xD4%\x3\x2\x2"+
		"\x2\xD5\xD9\x5\f\a\x2\xD6\xDA\a\v\x2\x2\xD7\xD8\a\f\x2\x2\xD8\xDA\b\x14"+
		"\x1\x2\xD9\xD6\x3\x2\x2\x2\xD9\xD7\x3\x2\x2\x2\xD9\xDA\x3\x2\x2\x2\xDA"+
		"\xDB\x3\x2\x2\x2\xDB\xDC\b\x14\x1\x2\xDC\'\x3\x2\x2\x2\xDD\xE3\x5*\x16"+
		"\x2\xDE\xDF\a\r\x2\x2\xDF\xE0\b\x15\x1\x2\xE0\xE2\x5*\x16\x2\xE1\xDE\x3"+
		"\x2\x2\x2\xE2\xE5\x3\x2\x2\x2\xE3\xE1\x3\x2\x2\x2\xE3\xE4\x3\x2\x2\x2"+
		"\xE4\xE6\x3\x2\x2\x2\xE5\xE3\x3\x2\x2\x2\xE6\xE7\b\x15\x1\x2\xE7)\x3\x2"+
		"\x2\x2\xE8\xEE\x5,\x17\x2\xE9\xEA\a\xE\x2\x2\xEA\xEB\b\x16\x1\x2\xEB\xED"+
		"\x5,\x17\x2\xEC\xE9\x3\x2\x2\x2\xED\xF0\x3\x2\x2\x2\xEE\xEC\x3\x2\x2\x2"+
		"\xEE\xEF\x3\x2\x2\x2\xEF\xF1\x3\x2\x2\x2\xF0\xEE\x3\x2\x2\x2\xF1\xF2\b"+
		"\x16\x1\x2\xF2+\x3\x2\x2\x2\xF3\xF7\x5.\x18\x2\xF4\xF5\a\xF\x2\x2\xF5"+
		"\xF6\b\x17\x1\x2\xF6\xF8\x5.\x18\x2\xF7\xF4\x3\x2\x2\x2\xF7\xF8\x3\x2"+
		"\x2\x2\xF8\xF9\x3\x2\x2\x2\xF9\xFA\b\x17\x1\x2\xFA-\x3\x2\x2\x2\xFB\x105"+
		"\x5\x30\x19\x2\xFC\xFD\a\x33\x2\x2\xFD\x101\b\x18\x1\x2\xFE\xFF\a!\x2"+
		"\x2\xFF\x101\b\x18\x1\x2\x100\xFC\x3\x2\x2\x2\x100\xFE\x3\x2\x2\x2\x101"+
		"\x102\x3\x2\x2\x2\x102\x104\x5\x30\x19\x2\x103\x100\x3\x2\x2\x2\x104\x107"+
		"\x3\x2\x2\x2\x105\x103\x3\x2\x2\x2\x105\x106\x3\x2\x2\x2\x106\x108\x3"+
		"\x2\x2\x2\x107\x105\x3\x2\x2\x2\x108\x109\b\x18\x1\x2\x109/\x3\x2\x2\x2"+
		"\x10A\x11E\x5\x32\x1A\x2\x10B\x10C\a\x36\x2\x2\x10C\x11A\b\x19\x1\x2\x10D"+
		"\x10E\a\x37\x2\x2\x10E\x11A\b\x19\x1\x2\x10F\x110\a\x38\x2\x2\x110\x11A"+
		"\b\x19\x1\x2\x111\x112\a\x39\x2\x2\x112\x11A\b\x19\x1\x2\x113\x114\a\a"+
		"\x2\x2\x114\x11A\b\x19\x1\x2\x115\x116\a\x10\x2\x2\x116\x11A\b\x19\x1"+
		"\x2\x117\x118\a\x11\x2\x2\x118\x11A\b\x19\x1\x2\x119\x10B\x3\x2\x2\x2"+
		"\x119\x10D\x3\x2\x2\x2\x119\x10F\x3\x2\x2\x2\x119\x111\x3\x2\x2\x2\x119"+
		"\x113\x3\x2\x2\x2\x119\x115\x3\x2\x2\x2\x119\x117\x3\x2\x2\x2\x11A\x11B"+
		"\x3\x2\x2\x2\x11B\x11D\x5\x32\x1A\x2\x11C\x119\x3\x2\x2\x2\x11D\x120\x3"+
		"\x2\x2\x2\x11E\x11C\x3\x2\x2\x2\x11E\x11F\x3\x2\x2\x2\x11F\x121\x3\x2"+
		"\x2\x2\x120\x11E\x3\x2\x2\x2\x121\x122\b\x19\x1\x2\x122\x31\x3\x2\x2\x2"+
		"\x123\x12D\x5\x34\x1B\x2\x124\x125\a:\x2\x2\x125\x129\b\x1A\x1\x2\x126"+
		"\x127\a;\x2\x2\x127\x129\b\x1A\x1\x2\x128\x124\x3\x2\x2\x2\x128\x126\x3"+
		"\x2\x2\x2\x129\x12A\x3\x2\x2\x2\x12A\x12C\x5\x34\x1B\x2\x12B\x128\x3\x2"+
		"\x2\x2\x12C\x12F\x3\x2\x2\x2\x12D\x12B\x3\x2\x2\x2\x12D\x12E\x3\x2\x2"+
		"\x2\x12E\x130\x3\x2\x2\x2\x12F\x12D\x3\x2\x2\x2\x130\x131\b\x1A\x1\x2"+
		"\x131\x33\x3\x2\x2\x2\x132\x13E\x5\x36\x1C\x2\x133\x134\a.\x2\x2\x134"+
		"\x13A\b\x1B\x1\x2\x135\x136\a\x12\x2\x2\x136\x13A\b\x1B\x1\x2\x137\x138"+
		"\a\x31\x2\x2\x138\x13A\b\x1B\x1\x2\x139\x133\x3\x2\x2\x2\x139\x135\x3"+
		"\x2\x2\x2\x139\x137\x3\x2\x2\x2\x13A\x13B\x3\x2\x2\x2\x13B\x13D\x5\x36"+
		"\x1C\x2\x13C\x139\x3\x2\x2\x2\x13D\x140\x3\x2\x2\x2\x13E\x13C\x3\x2\x2"+
		"\x2\x13E\x13F\x3\x2\x2\x2\x13F\x141\x3\x2\x2\x2\x140\x13E\x3\x2\x2\x2"+
		"\x141\x142\b\x1B\x1\x2\x142\x35\x3\x2\x2\x2\x143\x144\a;\x2\x2\x144\x145"+
		"\x5\x36\x1C\x2\x145\x146\b\x1C\x1\x2\x146\x149\x3\x2\x2\x2\x147\x149\x5"+
		"\x38\x1D\x2\x148\x143\x3\x2\x2\x2\x148\x147\x3\x2\x2\x2\x149\x37\x3\x2"+
		"\x2\x2\x14A\x159\x5<\x1F\x2\x14B\x14C\a\x13\x2\x2\x14C\x159\b\x1D\x1\x2"+
		"\x14D\x14E\a\x1B\x2\x2\x14E\x159\b\x1D\x1\x2\x14F\x159\x5@!\x2\x150\x159"+
		"\x5:\x1E\x2\x151\x159\x5\x16\f\x2\x152\x153\a\"\x2\x2\x153\x154\x5\b\x5"+
		"\x2\x154\x155\a#\x2\x2\x155\x156\b\x1D\x1\x2\x156\x159\x3\x2\x2\x2\x157"+
		"\x159\x5\f\a\x2\x158\x14A\x3\x2\x2\x2\x158\x14B\x3\x2\x2\x2\x158\x14D"+
		"\x3\x2\x2\x2\x158\x14F\x3\x2\x2\x2\x158\x150\x3\x2\x2\x2\x158\x151\x3"+
		"\x2\x2\x2\x158\x152\x3\x2\x2\x2\x158\x157\x3\x2\x2\x2\x159\x39\x3\x2\x2"+
		"\x2\x15A\x15B\a\x1A\x2\x2\x15B\x15F\a\"\x2\x2\x15C\x15D\x5\b\x5\x2\x15D"+
		"\x15E\b\x1E\x1\x2\x15E\x160\x3\x2\x2\x2\x15F\x15C\x3\x2\x2\x2\x15F\x160"+
		"\x3\x2\x2\x2\x160\x161\x3\x2\x2\x2\x161\x162\a#\x2\x2\x162\x163\b\x1E"+
		"\x1\x2\x163;\x3\x2\x2\x2\x164\x165\a\x19\x2\x2\x165\x169\b\x1F\x1\x2\x166"+
		"\x167\a\x17\x2\x2\x167\x169\b\x1F\x1\x2\x168\x164\x3\x2\x2\x2\x168\x166"+
		"\x3\x2\x2\x2\x169=\x3\x2\x2\x2\x16A\x16B\a\x14\x2\x2\x16B\x16C\a\"\x2"+
		"\x2\x16C\x16D\x5\n\x6\x2\x16D\x16E\a#\x2\x2\x16E\x16F\a\x15\x2\x2\x16F"+
		"\x170\x5\n\x6\x2\x170\x171\a\x16\x2\x2\x171\x172\x5\n\x6\x2\x172\x173"+
		"\b \x1\x2\x173?\x3\x2\x2\x2\x174\x175\a\x36\x2\x2\x175\x179\a\x1A\x2\x2"+
		"\x176\x178\x5\x44#\x2\x177\x176\x3\x2\x2\x2\x178\x17B\x3\x2\x2\x2\x179"+
		"\x177\x3\x2\x2\x2\x179\x17A\x3\x2\x2\x2\x17A\x17C\x3\x2\x2\x2\x17B\x179"+
		"\x3\x2\x2\x2\x17C\x17D\a\x37\x2\x2\x17D\x17E\x5\x42\"\x2\x17E\x17F\a\x42"+
		"\x2\x2\x17F\x180\a\x1A\x2\x2\x180\x181\a\x37\x2\x2\x181\x182\b!\x1\x2"+
		"\x182\x41\x3\x2\x2\x2\x183\x18D\x5<\x1F\x2\x184\x187\x5@!\x2\x185\x187"+
		"\x5\x46$\x2\x186\x184\x3\x2\x2\x2\x186\x185\x3\x2\x2\x2\x187\x188\x3\x2"+
		"\x2\x2\x188\x186\x3\x2\x2\x2\x188\x189\x3\x2\x2\x2\x189\x18A\x3\x2\x2"+
		"\x2\x18A\x18B\b\"\x1\x2\x18B\x18D\x3\x2\x2\x2\x18C\x183\x3\x2\x2\x2\x18C"+
		"\x186\x3\x2\x2\x2\x18D\x43\x3\x2\x2\x2\x18E\x18F\a\x1A\x2\x2\x18F\x190"+
		"\a!\x2\x2\x190\x191\x5<\x1F\x2\x191\x192\b#\x1\x2\x192\x195\x3\x2\x2\x2"+
		"\x193\x195\x5\x46$\x2\x194\x18E\x3\x2\x2\x2\x194\x193\x3\x2\x2\x2\x195"+
		"\x45\x3\x2\x2\x2\x196\x197\a)\x2\x2\x197\x198\x5\b\x5\x2\x198\x199\a*"+
		"\x2\x2\x199G\x3\x2\x2\x2$N]ot\x82\x87\x8E\x95\xA3\xAA\xB0\xB2\xD0\xD9"+
		"\xE3\xEE\xF7\x100\x105\x119\x11E\x128\x12D\x139\x13E\x148\x158\x15F\x168"+
		"\x179\x186\x188\x18C\x194";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
